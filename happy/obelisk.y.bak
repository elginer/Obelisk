{ 
-- | Parser for obelisk.  Generated by happy.  See happy/obelisk.y
module Language.Obelisk.Parser where

import Prelude hiding (lex)

import Language.Obelisk.Parser.Monad

import Language.Obelisk.Lexer
import Language.Obelisk.Lexer.Token

import Language.Obelisk.AST.Simple

import Text.Parsec.Pos

parse :: Parse

terror :: Token -> OParser a
terror = fail . show 

}

{- Parse is the name of the main parsing function -}
%name parse Obelisk

{- We're parsing tokens as defined in Language.Obelisk.Lexer.Token -}
%tokentype { Token }

{- parse_error is our error function -}
%error { terror }

{- We're using a monadic lexer provided by Language.Obelisk.Lexer -}
%lexer { lex } { TEOF } 

{- We're using a monad -}
%monad { OParser }

{- Declare tokens -}
%token
   def       { TDef }
   if        { TIf }
   int       { TInt $$ }
   var       { TVar $$ }
   op        { TOp $$ }
   true      { TTrue }
   false     { TFalse }
   set  { LocalSetter }
   '('       { TParOpen }
   ')'       { TParClose }

{- Declare precedence -}

%right set
%left op

%%

{- Get the source position -}
Pos :: { SourcePos }
Pos : {- empty -} {% get_pos}

{- Parse the AST -}
Obelisk :: { SimpleObelisk }
Obelisk : Stmts   { Obelisk $1 }

{- Parse a list of statements -}
Stmts :: { [SimpleStmt] }
Stmts : {- empty -}   { [] }
      | Stmt          { [$1] }
      | Stmts Stmt    { $2 : $1 }

{- Parse a statement, wrapped in parenthesis -}
Stmt :: { SimpleStmt }
Stmt : Stmtexp    { $1 }
     | '(' Stmt1 ')'   { $2 }



{- Parse a statement -}
Stmt1 :: { SimpleStmt }
Stmt1 : Def        { $1 }
      | If         { $1 }
      | LocalSet   { $1 }

{- Define a function -}
Def :: { SimpleStmt }
Def : Pos def var FArgs Returner   { Def $1 $3 $4 $5 }

{- A function's formal arguments -}
FArgs :: { [String] }
FArgs : {- empty -}    { [] }
      | '(' Vars ')'   { $2 }


{- A list of variables -}
Vars :: { [String] }
Vars : var        { [$1] }
     | Vars var   { $2 : $1 }


{- If statement -}
If :: { SimpleStmt }
If : Pos if Exp Returner Returner   { If $1 $3 $4 $5 }

{- Set a local variable -}
LocalSet :: { SimpleStmt }
LocalSet : Pos var set Exp   { SetLocal $1 $2 $4 }

{- Execute an expression -}
Stmtexp :: { SimpleStmt }
Stmtexp : Pos '(' PExp ')'  { StmtExp $1 $3 }

{- An expression within parenthesis, so using some rules without. -}
PExp :: { SimpleExp }
PExp : Apply   { $1 }
     | Infix   { $1 }
     | Var     { $1 }
     | Int     { $1 }
     | Bool    { $1 }
   

{- An expression -}
Exp :: { SimpleExp }
Exp : PApply   { $1 }
    | PInfix   { $1 }
    | Var     { $1 }
    | Int     { $1 }
    | Bool    { $1 }

{- Function application. -}
Apply :: { SimpleExp }
Apply : Pos Exp Exps   { Apply $1 $2 $3 }

{- Infix application. -}
Infix :: { SimpleExp }
Infix : Pos Exp op Exp   { Infix $1 $2 $3 $4 }


{- Function application. -}
PApply :: { SimpleExp }
PApply : Pos '(' Exp Exps ')'   { Apply $1 $3 $4 }

{- A list of expressions -}
Exps :: { [SimpleExp] }
Exps : {- empty -}   { [] }
     | Exps Exp      { $2 : $1 }

{- Infix application. -}
PInfix :: { SimpleExp }
PInfix : Pos '(' Exp op Exp ')'   { Infix $1 $3 $4 $5}

{- Variable used in expressions -}
Var :: { SimpleExp }
Var : Pos var   { OVar $1 $2 }

{- Integers -}
Int :: { SimpleExp }
Int : Pos int   { OInt $1 $2 }

{- Booleans -}
Bool :: { SimpleExp }
Bool : Pos true   { OBool $1 True }
     | Pos false  { OBool $1 True }

{- Returning code -}
Returner :: { SimpleReturner }
Returner : Pos '(' Obelisk Exp ')'  { Returner $1 $3 $4 }
