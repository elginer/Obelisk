{ 
-- | Parser for obelisk.  Generated by happy.  See happy/obelisk.y
module Language.Obelisk.Parser where

import Language.Obelisk.Parser.Monad

import Language.Obelisk.Lexer
import Language.Obelisk.Lexer.Token

import Language.Obelisk.AST.Simple

import Text.Parsec.Pos

}

{- Parse is the name of the main parsing function -}
%name parse

{- We're parsing tokens as defined in Language.Obelisk.Lexer.Token -}
%tokentype { Token }

{- parse_error is our error function -}
%error parse_error

{- We're using a monadic lexer provided by Language.Obelisk.Lexer -}
%lexer { lex } { TEOF } 

{- Declare tokens -}
%token
   def       { TDef }
   if        { TIf }
   int       { TInt $$ }
   var       { TVar $$ }
   op        { TOp $$ }
   true      { TTrue }
   false     { TFalse }
   localset  { LocalSetter }
   globalset { GlobalSetter }
   '('       { TParOpen }
   ')'       { TParClose }

%%

{- Get the source position -}
Pos :: { SourcePos }
Pos : {- empty -} {% get_pos}

{- Parse the AST -}
Obelisk :: { SimpleObelisk }
Obelisk : Stmts   { Obelisk $1 }

{- Parse a list of statements -}
Stmts :: { [SimpleStmt] }
Stmts : {- empty -}   { [] }
      | Stmt          { [$1] }
      | Stmts Stmt    { $2 : $1 }

{- Parse a statement, wrapped in parenthesis -}
Stmt :: { SimpleStmt }
Stmt : '(' Stmt1 ')'

{- Parse a statement -}
Stmt1 :: { SimpleStmt }
Stmt1 : Def
      | If
      | Localset 
      | Stmtexp

{- Define a function -}
Def :: { SimpleStmt }
Def : Pos def '(' Vars ')' Returner   { Def $1 $4 $6 }

{- If statement -}
If :: { SimpleStmt }
If : Pos if Exp Returner Returner   { If $1 $3 $4 $5 }

{- Set a local variable -}
LocalSet :: { SimpleStmt }
LocalSet : Pos var local Exp   { SetLocal $1 $2 $4 }

{- Execute an expression -}
Stmtexp :: { SimpleStmt }
Stmtexp : Pos Exp   { StmtExp $1 $2 }

{- An expression -}
Exp :: { SimpleExp }
Exp : Apply
    | Infix
    | Var
    | Int
    | Bool

{- Function application. -}
Apply :: { SimpleExp }
Apply : Pos '(' Exp Exps ')'   { Apply $1 $3 $4 }

{- Infix application. -}
Infix :: { SimpleExp }
Infix : Pos '(' Exp Op Exp ')'   { Infix $1 $3 $4 $5}

{- Variable used in expressions -}
Var :: { SimpleExp }
Var : Pos var   { OVar $1 $2 }

{- Integers -}
Int :: { SimpleExp }
Int : Pos int   { OInt $1 $2 }

{- Booleans -}
Bool :: { SimpleExp }
Bool : Pos bool   { OBool $1 $2 }

{- Returning code -}
Returner :: { SimpleReturner }
Returner : Pos '(' Obelisk Exp ')'  { Returner $1 $3 $4 }
