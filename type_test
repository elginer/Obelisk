--------------------------------------------------

Type checker must report success:

test:

// Function returning Int
((Int) # def foo (0))

Success!
--------------------------------------------------

Type checker must report success:

test:

// If statement both branches same
((Int) # def foo ((if true (0) (1))))

Success!
--------------------------------------------------

Type checker must report success:

test:

// Self function application
((Int -> Int) # def foo x ((foo x)))

Success!
--------------------------------------------------

Type checker must report success:

test:

// Multiple application
((Int -> Int) # def foo x ((foo x) (bar x)))
((Int -> Int) # def bar x ((foo x)))

Success!
--------------------------------------------------

Type checker must report success:

test:

// Application inside If
((Int -> Int) # def foo x (x))
((Int) # def bar ((if false ((foo 1)) ((foo 2)))))

Success!
--------------------------------------------------

Type checker must report success:

test:

// Multiple expressions inside if
((Int) # def foo ((if true (1 2 3) (1 2 3 4))))

Success!
--------------------------------------------------

Type checker must report success:

test:

// Empty block returns void
((Void) # def foo ())

Success!
--------------------------------------------------

Type checker must report success:

test:

// Application in if statement test
((Bool -> Bool) # def foo x (x))
((Void) # def bar ((if (foo true) () ())))

Success!
--------------------------------------------------

Type checker must report success:

test:

// Wrap in where clause
((Void) # def wrapper () where (

// Function returning Int
((Int) # def foo (0))

))

Success!
--------------------------------------------------

Type checker must report success:

test:

// Wrap in where clause
((Void) # def wrapper () where (

// If statement both branches same
((Int) # def foo ((if true (0) (1))))

))

Success!
--------------------------------------------------

Type checker must report success:

test:

// Wrap in where clause
((Void) # def wrapper () where (

// Self function application
((Int -> Int) # def foo x ((foo x)))

))

Success!
--------------------------------------------------

Type checker must report success:

test:

// Wrap in where clause
((Void) # def wrapper () where (

// Multiple application
((Int -> Int) # def foo x ((foo x) (bar x)))
((Int -> Int) # def bar x ((foo x)))

))

Success!
--------------------------------------------------

Type checker must report success:

test:

// Wrap in where clause
((Void) # def wrapper () where (

// Application inside If
((Int -> Int) # def foo x (x))
((Int) # def bar ((if false ((foo 1)) ((foo 2)))))

))

Success!
--------------------------------------------------

Type checker must report success:

test:

// Wrap in where clause
((Void) # def wrapper () where (

// Multiple expressions inside if
((Int) # def foo ((if true (1 2 3) (1 2 3 4))))

))

Success!
--------------------------------------------------

Type checker must report success:

test:

// Wrap in where clause
((Void) # def wrapper () where (

// Empty block returns void
((Void) # def foo ())

))

Success!
--------------------------------------------------

Type checker must report success:

test:

// Wrap in where clause
((Void) # def wrapper () where (

// Application in if statement test
((Bool -> Bool) # def foo x (x))
((Void) # def bar ((if (foo true) () ())))

))

Success!
--------------------------------------------------

Type checker must report failure:

test:

// Function's type says Int, but returns Bool
((Int) # def foo (true))

Type error:
      Wrong type.
      The type expected was:
      Int
      But the type received was:
      Bool
            In "failure" (line 2, column 23)
            Near code:
                  true))
--------------------------------------------------

Type checker must report failure:

test:

// Function returns itself.  Note: no current way to do this!  This should be success.....
((Int) # def foo (foo))

Type error:
      Wrong type.
      The type expected was:
      Int
      But the type received was:
      (Int)
            In "failure" (line 2, column 22)
            Near code:
                  foo))
--------------------------------------------------

Type checker must report failure:

test:

// If statement branches different
((Int) # def foo ((if true (0) (false))))

Type error:
      The two branches of an if statement did not have the same type
      The type of the 'true' branch was:
      Int
      But the type of the 'false' branch was:
      Bool
      In "failure" (line 2, column 23)
      Near code:
            if true (0) (false))))
--------------------------------------------------

Type checker must report failure:

test:

// Incorrect function self application
((Int -> Int) # def foo x ((foo true)))

Type error:
      Wrong type.
      The type expected was:
      Int
      But the type received was:
      Bool
            In "failure" (line 2, column 33)
            Near code:
                  foo true)))
--------------------------------------------------

Type checker must report failure:

test:

// Incorrect multiple application
((Bool -> Int) # def foo x ((foo x) (bar x)))
((Int -> Int) # def bar x ((foo x)))

Type error:
      Wrong type.
      The type expected was:
      Int
      But the type received was:
      Bool
            In "failure" (line 2, column 42)
            Near code:
                  bar x)))

--------------------------------------------------

Type error:
      Wrong type.
      The type expected was:
      Bool
      But the type received was:
      Int
            In "failure" (line 3, column 33)
            Near code:
                  foo x)))
--------------------------------------------------

Type checker must report failure:

test:

// Incorrect application inside If
((Int -> Bool) # def foo x (x))
((Int) # def bar ((if false ((foo 1)) ((foo 2)))))

Type error:
      Wrong type.
      The type expected was:
      Bool
      But the type received was:
      Int
            In "failure" (line 2, column 30)
            Near code:
                  x))

--------------------------------------------------

Type error:
      Wrong type.
      The type expected was:
      Int
      But the type received was:
      Bool
            In "failure" (line 3, column 23)
            Near code:
                  if false ((foo 1)) ((foo 2)))))
--------------------------------------------------

Type checker must report failure:

test:

// Incorrect multiple expressions inside if
((Bool) # def foo ((if true (true true 3) (true 2 true 4))))

Type error:
      Wrong type.
      The type expected was:
      Bool
      But the type received was:
      Int
            In "failure" (line 2, column 24)
            Near code:
                  if true (true true 3) (true 2 true 4))))
--------------------------------------------------

Type checker must report failure:

test:

// Empty block returns something other than void
((Double) # def foo ())

Type error:
      Wrong type.
      The type expected was:
      Double
      But the type received was:
      Void
            In "failure" (line 2, column 22)
            Near code:
                  ())
--------------------------------------------------

Type checker must report failure:

test:

// Incorrect application in if statement test
((Bool -> Int) # def foo x (0))
((Void) # def bar ((if (foo true) () ())))

Type error:
      Wrong type.
      The type expected was:
      Bool
      But the type received was:
      Int
            In "failure" (line 3, column 29)
            Near code:
                  foo true) () ())))
--------------------------------------------------

Type checker must report failure:

test:

// Wrong number of formal arguments
((Int -> Int -> Int) # def foo x (x))
((Int -> Int) # def bar x y (x))

Type error:
      The number of arguments in a function's type signature
      is different from the number of arguments in its implementation.
      The type signature has 2 arguments.
      The implementation has 1 arguments.
            In "failure" (line 2, column 3)
            Near code:
                  (Int -> Int -> Int) # def foo x (x))

--------------------------------------------------

Type error:
      The number of arguments in a function's type signature
      is different from the number of arguments in its implementation.
      The type signature has 1 arguments.
      The implementation has 2 arguments.
            In "failure" (line 3, column 3)
            Near code:
                  (Int -> Int) # def bar x y (x))
--------------------------------------------------

Type checker must report failure:

test:

// Wrong number of actual arguments
((Int -> Int -> Int) # def foo x y (x))
((Void) # def bar ((foo 1)))
((Void) # def baz ((foo 1 2 3)))

Type error:
      The number of arguments applied to a function is not equal to the number of arguments the function has.
      The function has 2 arguments,
      but 1 arguments were applied.
      In "failure" (line 3, column 25)
      Near code:
            foo 1)))

--------------------------------------------------

Type error:
      The number of arguments applied to a function is not equal to the number of arguments the function has.
      The function has 2 arguments,
      but 3 arguments were applied.
      In "failure" (line 4, column 25)
      Near code:
            foo 1 2 3)))
--------------------------------------------------

Type checker must report failure:

test:

// Wrap in where clause
((Void) # def wrapper () where (

// Function's type says Int, but returns Bool
((Int) # def foo (true))

))

Type error:
      Wrong type.
      The type expected was:
      Int
      But the type received was:
      Bool
            In "failure" (line 5, column 23)
            Near code:
                  true))
--------------------------------------------------

Type checker must report failure:

test:

// Wrap in where clause
((Void) # def wrapper () where (

// Function returns itself.  Note: no current way to do this!  This should be success.....
((Int) # def foo (foo))

))

Type error:
      Wrong type.
      The type expected was:
      Int
      But the type received was:
      (Int)
            In "failure" (line 5, column 22)
            Near code:
                  foo))
--------------------------------------------------

Type checker must report failure:

test:

// Wrap in where clause
((Void) # def wrapper () where (

// If statement branches different
((Int) # def foo ((if true (0) (false))))

))

Type error:
      The two branches of an if statement did not have the same type
      The type of the 'true' branch was:
      Int
      But the type of the 'false' branch was:
      Bool
      In "failure" (line 5, column 23)
      Near code:
            if true (0) (false))))
--------------------------------------------------

Type checker must report failure:

test:

// Wrap in where clause
((Void) # def wrapper () where (

// Incorrect function self application
((Int -> Int) # def foo x ((foo true)))

))

Type error:
      Wrong type.
      The type expected was:
      Int
      But the type received was:
      Bool
            In "failure" (line 5, column 33)
            Near code:
                  foo true)))
--------------------------------------------------

Type checker must report failure:

test:

// Wrap in where clause
((Void) # def wrapper () where (

// Incorrect multiple application
((Bool -> Int) # def foo x ((foo x) (bar x)))
((Int -> Int) # def bar x ((foo x)))

))

Type error:
      Wrong type.
      The type expected was:
      Bool
      But the type received was:
      Int
            In "failure" (line 6, column 33)
            Near code:
                  foo x)))

--------------------------------------------------

Type error:
      Wrong type.
      The type expected was:
      Int
      But the type received was:
      Bool
            In "failure" (line 5, column 42)
            Near code:
                  bar x)))
--------------------------------------------------

Type checker must report failure:

test:

// Wrap in where clause
((Void) # def wrapper () where (

// Incorrect application inside If
((Int -> Bool) # def foo x (x))
((Int) # def bar ((if false ((foo 1)) ((foo 2)))))

))

Type error:
      Wrong type.
      The type expected was:
      Int
      But the type received was:
      Bool
            In "failure" (line 6, column 23)
            Near code:
                  if false ((foo 1)) ((foo 2)))))

--------------------------------------------------

Type error:
      Wrong type.
      The type expected was:
      Bool
      But the type received was:
      Int
            In "failure" (line 5, column 30)
            Near code:
                  x))
--------------------------------------------------

Type checker must report failure:

test:

// Wrap in where clause
((Void) # def wrapper () where (

// Incorrect multiple expressions inside if
((Bool) # def foo ((if true (true true 3) (true 2 true 4))))

))

Type error:
      Wrong type.
      The type expected was:
      Bool
      But the type received was:
      Int
            In "failure" (line 5, column 24)
            Near code:
                  if true (true true 3) (true 2 true 4))))
--------------------------------------------------

Type checker must report failure:

test:

// Wrap in where clause
((Void) # def wrapper () where (

// Empty block returns something other than void
((Double) # def foo ())

))

Type error:
      Wrong type.
      The type expected was:
      Double
      But the type received was:
      Void
            In "failure" (line 5, column 22)
            Near code:
                  ())
--------------------------------------------------

Type checker must report failure:

test:

// Wrap in where clause
((Void) # def wrapper () where (

// Incorrect application in if statement test
((Bool -> Int) # def foo x (0))
((Void) # def bar ((if (foo true) () ())))

))

Type error:
      Wrong type.
      The type expected was:
      Bool
      But the type received was:
      Int
            In "failure" (line 6, column 29)
            Near code:
                  foo true) () ())))
--------------------------------------------------

Type checker must report failure:

test:

// Wrap in where clause
((Void) # def wrapper () where (

// Wrong number of formal arguments
((Int -> Int -> Int) # def foo x (x))
((Int -> Int) # def bar x y (x))

))

Type error:
      The number of arguments in a function's type signature
      is different from the number of arguments in its implementation.
      The type signature has 1 arguments.
      The implementation has 2 arguments.
            In "failure" (line 6, column 3)
            Near code:
                  (Int -> Int) # def bar x y (x))

--------------------------------------------------

Type error:
      The number of arguments in a function's type signature
      is different from the number of arguments in its implementation.
      The type signature has 2 arguments.
      The implementation has 1 arguments.
            In "failure" (line 5, column 3)
            Near code:
                  (Int -> Int -> Int) # def foo x (x))
--------------------------------------------------

Type checker must report failure:

test:

// Wrap in where clause
((Void) # def wrapper () where (

// Wrong number of actual arguments
((Int -> Int -> Int) # def foo x y (x))
((Void) # def bar ((foo 1)))
((Void) # def baz ((foo 1 2 3)))

))

Type error:
      The number of arguments applied to a function is not equal to the number of arguments the function has.
      The function has 2 arguments,
      but 3 arguments were applied.
      In "failure" (line 7, column 25)
      Near code:
            foo 1 2 3)))

--------------------------------------------------

Type error:
      The number of arguments applied to a function is not equal to the number of arguments the function has.
      The function has 2 arguments,
      but 1 arguments were applied.
      In "failure" (line 6, column 25)
      Near code:
            foo 1)))
