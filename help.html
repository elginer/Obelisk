<html>
   <head>
      <title>The Obelisk Programming Language</title>
      <style type="text/css">
      .code {background-color: #222222; font-size: x-large; font-family: monospace; color: yellow;}
      body {font-family: sans-serif;}
      </style>
   </head>
   <body>
      <h1>The Obelisk Programming Language</h2>
      <h2>Copyright John Morrice 2010</h2>
      <h3>Released under the terms of the GNU GPL-3.  See the file 'LICENCE'.</h3>
      <p>Obelisk is a general purpose systems programming language.  Its type system supports parametric polymorphism (generics), as well as objects and classes with inheritance (subtype polymorphism).  Obelisk supports anonymous, higher order functions and tail-call optimization, so explicit loops can be replaced by functional constructs.<p>
      <p>Contents:
         </br>
         &nbsp;&nbsp;&nbsp;<a href="#syntax">1. Syntax</a></br>
         &nbsp;&nbsp;&nbsp;<a href="#semantics">2. Semantics</a></br>
         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#scope">2.1 Scoping rules</a></br>
      </p>
      <a name="syntax">
         <h1>1. Syntax</h1>
      </a>
      <p>
            Obelisk's syntax is described by this <a href="happy/obelisk.y">happy file.</a>
      </p>
      <p>
         Here is a description in mock-bnf.
      </p>
      <p class="code">
         // The source is a list of definitions</br>
         obelisk: fdef obelisk</br></br>

         // A function definition
         fdef: '(' 'def' vars '(' stmts ')' [ 'where' '(' defs ')' ] ')</br></br>

         // A list of definitions
         defs: def defs

         // definitions are either a function...</br>
         def: fdef</br>
            &nbsp;&nbsp;&nbsp;// or a constant</br>
            &nbsp;&nbsp;&nbsp;| '(' 'let' var exp ')' </br></br>

         // A statement is a list of expressions</br>
         stmts: stmtexp stmts </br></br>

         stmtexp: exp</br></br>

         // An expression, to be evaluated at runtime
         exp: if | number | var | '(' vars ')' | '(' exp operator exp ')' | 'true' | 'false'</br></br>

         // An if statement.</br>
         if:  'if' exp '(' obelisk exp ')' '(' obelisk exp ')'</br></br>

         // A list of variables </br>
         vars: var vars
             
      </p>
      <p>Here is an example, which defines a function called add:</p>
      <a name="example1">
         <p class="code">
            (def add x y</br>
            &nbsp;&nbsp;&nbsp;((x + y)))
         </p>
      </a>
      <a name="semantics">
         <h1>
            2. Semantics
         </h1>
      </a>
      <a name="scope">
         <h2>
            2.1 Scope
         </h2>
      </a>
      <p>
         An obelisk source file consists of a series of top level function definitions.</br>
         These definitions are always in scope.</br>
      </p>
      <a name="example2.1">
         <p class="code">
            // The functions x and y can each return the other, because they share the same scope.</br>
            (def x (y))</br>
            (def y (x))</br>
         </p>
      </a>
      <p>
         Each function definition has an optional where clause, which can introduce new functions and constants into the scope of the function.
      </p>
      <a name="example2.2">
      <p class="code">
         // Increment an integer by 1</br>
         (def inc1 x (y)</br>
         &nbsp;&nbsp;&nbsp;where</br>
         &nbsp;&nbsp;&nbsp;((let y (x + 1))))
         </br></br>
         (def inc2 x ((incer x))</br>
         &nbsp;&nbsp;&nbsp;where</br>
         &nbsp;&nbsp;&nbsp;((def incer z ((z + 1)))))

      </p>
      </a>
      <p>
         Function definitions within a where clause can see one another, and a constant can take the value of a function.  However, functions defined within a where clause cannot see constants (as the constants may depend on the functions for their value).
      </p>
      <a name="example2.3">
         <p class="code">
            // These are legal</br>
            (def foo ()</br>
            &nbsp;&nbsp;&nbsp;where</br>
            &nbsp;&nbsp;&nbsp;((def bar (baz))</br>
            &nbsp;&nbsp;&nbsp;&nbsp;(def baz (bar))))
            </br></br>
            (def foo ()</br>
            &nbsp;&nbsp;&nbsp;where</br>
            &nbsp;&nbsp;&nbsp;((def bar zob ((zob + 1)))</br>
            &nbsp;&nbsp;&nbsp;&nbsp;(let baz (bar 3))))
            </br></br>
            // This is illegal</br>
            (def foo ()</br>
            &nbsp;&nbsp;&nbsp;where</br>
            &nbsp;&nbsp;&nbsp;((def bar (baz))</br>
            &nbsp;&nbsp;&nbsp;&nbsp;(let baz 0)))
         </p>
      </a>
      <p>
         It is also illegal for a constant or function declared within a where clause to share a name either with a formal argument of the function to which the where clause belongs, or with another member of the same where clause.  Similarly, it is illegal for two top level functions to have the same name, and for a function to have two formal arguments with the same name.
      </p>
      <a name="example2.4">
         <p class="code">
         // These are illegal</br>
         (def foo bar ()</br>
         &nbsp;&nbsp;&nbsp;where</br>
         &nbsp;&nbsp;&nbsp;((let bar 0)))
         </br></br>
         (def foo ()</br>
         &nbsp;&nbsp;&nbsp;where</br>
         &nbsp;&nbsp;&nbsp;((let bar 0))</br>
         &nbsp;&nbsp;&nbsp;&nbsp;(def bar ()))
         </p>
         <p>
            These rules ensure that there is no ambiguity in the naming of variables.
         </p>
      </a>
   </body>
</html>
