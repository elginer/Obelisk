<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><title>The Obelisk Programming Language</title><style type="text/css">/* 
  Copyright John Morrice 2010
  This document is part of The Obelisk Programming Language documentation
  This document is released under the terms of the GNU Free Documentation Licence
  See the file DOC-COPYING.
*/
.intro_banner {text-align: center;}
.example
{
   font-family: monospace; 
   font-size: x-large; 
   border-style:solid; 
   border-width: 0.05em;
   padding: 0.08em;
}
body {font: arial; font-family: sans;}
.boring {font-weight: bold}
.rfc {font-family: monospace: font-size: x-large}
/* The .stage class is for text about a compilation stage */
.stage {font-style: italic;}
</style></head><body><h1 class="intro_banner">The Obelisk Programming Language</h1><h2 class="intro_banner">Copyright John Morrice 2010</h2><h2 class="intro_banner">Contact: spoon@killersmurf.com</h2><p class="boring">This document is released under the terms of the GNU Free Documentation License. See the file <a href="DOC-COPYING"> DOC-COPYING</a> for details</p><p class="rfc">The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this document are to be interpreted as described in <a href="http://www.ietf.org/rfc/rfc2119.txt"> RFC 2119</a>.</p><p class="">Obelisk is a general purpose programming language.</p><p class="">Obelisk aims to:</p><p class="">* Be an eagerly evaluated, functional programming language.</p><p class="">* Support functions with expressive, polymorphic types, but to be utterly type safe.</p><p class="">*&nbsp;Respect&nbsp;functional&nbsp;purity,&nbsp;with&nbsp;no&nbsp;mutable&nbsp;variables&nbsp;in&nbsp;functions...&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...but&nbsp;also&nbsp;to&nbsp;support&nbsp;a&nbsp;class-based&nbsp;object&nbsp;system,&nbsp;where&nbsp;objects&nbsp;control&nbsp;mutable&nbsp;state,&nbsp;represented&nbsp;by&nbsp;their&nbsp;instance&nbsp;variables</p><p class="">* Be supportive of simple and efficient implementation: writing an Obelisk compiler which produces competitively fast code should not warrant a PhD dissertation.</p><p class="">* Be developed in an free and open manner.</p><h2 class="contents_announce">Contents:</h2><p><a href="#intro">1. Introduction</a><br /><a href="#syntax">2. Syntax</a><br />&nbsp;&nbsp;&nbsp;<a href="#lex">2.1. Lexical Syntax</a><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#reserved">2.1.1. Reserved Words And Special Symbols.</a><br />&nbsp;&nbsp;&nbsp;<a href="#grammar">2.2. Grammar</a><br /><a href="#semantics">3. Semantics</a><br />&nbsp;&nbsp;&nbsp;<a href="#correct">3.1. Correct Programs</a><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#scope">3.1.1. Scope</a><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#type">3.1.2. Type Unification</a><br /></p><h2 class="banner"><a name="intro">1. Introduction</a></h2><p class="">This file is a report on the current state of the Obelisk programming language. It describes a standard which compliant Obelisk implementations MUST meet. The Obelisk Compiler is the name of a free compiler which implements this standard.  In this report The Obelisk Compiler is also referred to as 'the compiler'.</p><p class="">This report is structured as the Obelisk compiler: each stage in compilation process is described, and in the order of execution of The Obelisk compiler.</p><p class="">This means that at first the lexical rules are described (associated with lexical analysis), before moving on to describe the syntax (associated with parsing, after lexical analysis in the compiler chain), and so on, for all stages of the compiler, or equivalently with all aspects of the Obelisk programming language.</p><p class="">The advantage this approach is that each subsection can be analysed with respect to a single compiler subsystem. So if you are confused, or you suspect the a subsection of this report to be at odds with the behaviour of the compiler, you can easily find code which represents that subsection and find clarification.</p><p class="">In aid to that, links to files within appropriate subsystems of The Obelisk Compiler can be found in at the beginning of many sections.</p><p class="">This report contains many pieces of techincal information like code examples, and grammars.   These are rendered thus:</p><p class="example">I am a piece of technical information</p><h2 class="banner"><a name="syntax">2. Syntax</a></h2><p class="">This section deals with <a href="#lex"> lexical syntax</a> and <a href="#grammar"> Obelisk's grammar</a>.</p><h2 class="banner"><a name="lex">2.1. Lexical Syntax</a></h2><p class="stage">Lexical syntax is associated with the <a href="Language/Obelisk/Lexer.hs"> lexer</a>.</p><p class="">Before parsing, Obelisk source undergoes lexical analysis where comments and whitespace are removed. The legal tokens are then parsed as set out in <a href="#grammar"> 2.2 Grammar</a>.</p><p class="">Whitespace consists of the space character, aswell as the following characters, represented here by their escape codes:</p><p class="example"> \n\t\r </p><p class="">Obelisk supports both line and block comments.</p><p class="">Line comments are started by the token <span class="example"> //</span>  and last until the next newline.</p><p class="">Block comments are started by the token <span class="example"> /*</span> and last until the token <span class="example"> */</span>. Block comments in Obelisk are not nested.</p><p class="">Here is an example of source code running throught Obelisk's lexical analysis.  The source code before lexical analysis:</p><p class="example">//&nbsp;I&nbsp;say,&nbsp;you&nbsp;look&nbsp;very&nbsp;gruntled&nbsp;Jeeves!&nbsp;<br />&nbsp;<br />(Void)&nbsp;&nbsp;<br />#&nbsp;def&nbsp;functional&nbsp;programming&nbsp;<br />{&nbsp;<br />&nbsp;&nbsp;&nbsp;(is&nbsp;fun)&nbsp;<br />}&nbsp;<br />&nbsp;<br />/*&nbsp;That&nbsp;was&nbsp;a&nbsp;bit&nbsp;pointless&nbsp;<br />&nbsp;&nbsp;&nbsp;but&nbsp;hey&nbsp;ho,&nbsp;it&nbsp;was&nbsp;just&nbsp;an&nbsp;example!&nbsp;*/</p><p class="">The source code after lexical analysis:</p><p class="example">(Void) # def functional programming {(is fun)}</p><h2 class="banner"><a name="reserved">2.1.1. Reserved Words And Special Symbols.</a></h2><p class="">Reserved words are identified during lexical analysis. These reserved words are:</p><p class="example">op&nbsp;<br />&nbsp;<br />def&nbsp;<br />&nbsp;<br />where&nbsp;<br />&nbsp;<br />let&nbsp;<br />&nbsp;<br />true&nbsp;<br />&nbsp;<br />false&nbsp;<br />&nbsp;<br />if&nbsp;<br />&nbsp;<br />-&gt;</p><p class="">In addition, Obelisk's grammar assigns special significance to these symbols which are also identified during lexing:</p><p class="example">'&nbsp;<br />&nbsp;<br />(&nbsp;<br />&nbsp;<br />)&nbsp;<br />&nbsp;<br />{&nbsp;<br />&nbsp;<br />}&nbsp;<br />&nbsp;<br /></p><p class="">The primary difference between special symbols and reserved words, is that      an <a href="#grammar"> identifer</a> MAY contain a reserved word, but they MUST not contain special symbols.</p><h2 class="banner"><a name="grammar">2.2. Grammar</a></h2><p class="stage">A parser for Obelisk's grammar is generated from <a href="happy/obelisk.y"> this happy file.</a></p><p class="">Following is the syntax of Obelisk described in <a href="http://www.iso.org/iso/catalogue_detail.htm?csnumber=26153"> EBNF</a>.  <span class="example"> Obelisk</span> is the start symbol.</p><p class="example">(*&nbsp;Obelisk&nbsp;source&nbsp;is&nbsp;a&nbsp;sequence&nbsp;of&nbsp;function&nbsp;definitions.&nbsp;*)&nbsp;<br />Obelisk:&nbsp;FunctionDefinition*&nbsp;<br />&nbsp;<br />(*&nbsp;Definitions&nbsp;*)&nbsp;<br />&nbsp;<br />(*&nbsp;A&nbsp;function&nbsp;definition&nbsp;*)&nbsp;<br />Function&nbsp;:=&nbsp;FunctionType&nbsp;'def'&nbsp;FunctionName&nbsp;FormalArguments&nbsp;Block&nbsp;WhereClause&nbsp;<br />&nbsp;<br />(*&nbsp;Where&nbsp;Clause&nbsp;*)&nbsp;<br />WhereClause&nbsp;:=&nbsp;'where'&nbsp;'{'&nbsp;Definition*&nbsp;'}'&nbsp;|&nbsp;@&nbsp;<br />&nbsp;<br />(*&nbsp;Where&nbsp;clause&nbsp;definition&nbsp;*)&nbsp;<br />Definition&nbsp;:=&nbsp;Constant&nbsp;|&nbsp;Function&nbsp;<br />&nbsp;<br />(*&nbsp;Define&nbsp;a&nbsp;constant&nbsp;*)&nbsp;<br />Constant&nbsp;:=&nbsp;Type&nbsp;'let'&nbsp;Identifier&nbsp;Expression&nbsp;<br />&nbsp;<br />(*&nbsp;A&nbsp;function's&nbsp;name&nbsp;*)&nbsp;<br />FunctionName&nbsp;:=&nbsp;Identifier&nbsp;<br />&nbsp;<br />(*&nbsp;A&nbsp;function's&nbsp;formal&nbsp;arguments&nbsp;*)&nbsp;<br />FormalArguments&nbsp;:=&nbsp;Identifier*&nbsp;<br />&nbsp;<br />(*&nbsp;Expressions&nbsp;*)&nbsp;<br />&nbsp;<br />(*&nbsp;A&nbsp;block&nbsp;of&nbsp;code&nbsp;*)&nbsp;<br />Block&nbsp;:=&nbsp;'{'&nbsp;Expression*&nbsp;WhereClause&nbsp;'}'&nbsp;<br />&nbsp;<br />(*&nbsp;An&nbsp;expression&nbsp;*)&nbsp;<br />Expression&nbsp;:=&nbsp;If&nbsp;|&nbsp;Application&nbsp;|&nbsp;Identifier&nbsp;|&nbsp;Character&nbsp;|&nbsp;Integer&nbsp;<br />&nbsp;<br />(*&nbsp;If&nbsp;statement&nbsp;*)&nbsp;<br />If&nbsp;:=&nbsp;'if'&nbsp;Expression&nbsp;Block&nbsp;Block&nbsp;<br />&nbsp;<br />(*&nbsp;Function&nbsp;application&nbsp;*)&nbsp;<br />Application&nbsp;:=&nbsp;'('&nbsp;Expression+&nbsp;')'&nbsp;<br />&nbsp;<br />(*&nbsp;Values&nbsp;*)&nbsp;<br />&nbsp;<br />(*&nbsp;Character&nbsp;*)&nbsp;<br />Character&nbsp;:=&nbsp;'''&nbsp;(*&nbsp;Any&nbsp;character&nbsp;*)&nbsp;'''&nbsp;<br />&nbsp;<br />(*&nbsp;A&nbsp;value's&nbsp;identifier&nbsp;*)&nbsp;<br />Identifier&nbsp;:=&nbsp;Lowercase&nbsp;IdentChar*&nbsp;<br />&nbsp;<br />(*&nbsp;Characters&nbsp;permitted&nbsp;in&nbsp;an&nbsp;identifier&nbsp;*)&nbsp;<br />IdentChar&nbsp;:=&nbsp;(*&nbsp;An&nbsp;alpha&nbsp;numeric&nbsp;character&nbsp;*)&nbsp;|&nbsp;'_'&nbsp;|&nbsp;'?'&nbsp;|&nbsp;'!'&nbsp;<br />&nbsp;<br />(*&nbsp;Types&nbsp;*)&nbsp;<br />&nbsp;<br />(*&nbsp;A&nbsp;type&nbsp;*)&nbsp;<br />Type&nbsp;:=&nbsp;ClassName&nbsp;|&nbsp;FunctionType&nbsp;<br />&nbsp;<br />(*&nbsp;A&nbsp;function's&nbsp;type&nbsp;*)&nbsp;<br />FunctionType&nbsp;:=&nbsp;'('&nbsp;ClassName&nbsp;('-&gt;'&nbsp;ClassName)*&nbsp;')'&nbsp;<br />&nbsp;<br />(*&nbsp;A&nbsp;name&nbsp;of&nbsp;a&nbsp;data&nbsp;type&nbsp;*)&nbsp;<br />ClassName&nbsp;:=&nbsp;Uppercase&nbsp;IdentChar*</p><h2 class="banner"><a name="semantics">3. Semantics</a></h2><p class="">Obelisks semantics are described in two parts:</p><p class="">* Checking an Obelisk program for <a href="#correct"> correctness</a>.</p><p class="">* <a href="#runtime"> Run-time semantics</a> of an Obelisk program.</p><p class="">The following formal definitions are used throughout this section:</p><p class="">The set of available <a href="#grammar"> Obelisks grammar elements</a> is defined as <span class="example"> O</span>.</p><p class="">An Obelisk program <span class="example"> P</span>, which is a valid production of Obelisk's grammar - a list of function definitions.  Hence:</p><p class="example">A <span class="math_symbol">&#8712;</span> P <span class="math_symbol">&#8658;</span> A = FunctionDefinition</p><h2 class="banner"><a name="correct">3.1. Correct Programs</a></h2><p class="">An Obelisk program must not be executed as specified in the <a href="#runtime"> run-time semantics</a> unless it is correct.</p><p class="">An Obelisk program is correct when it has these two properties:</p><p class="">* A program has correct <a href="#scope"> scoping</a>.</p><p class="">* A program exhibits <a href="#unification"> type unification</a>.</p><h2 class="banner"><a name="scope">3.1.1. Scope</a></h2><p class="stage">The <a href="Language/Obelisk/Scoper.hs"> scoper</a> ensures scoping rules are obeyed.</p><p class="">The process of determining if an Obelisk program has correct scoping is described here.</p><p class="">An Obelisk program with correct scoping has the following properties when  <a href="#eval"> evaluated</a>:</p><p class="">* The program can never crash due to encountering an identifier it does not associate with data or a function.</p><p class=""><span class="example"> next_scope</span> is a relationship between and sets of variables in scope and sets with new members.   It is defined for each grammar element which contains other elements (is a set).</p><p class="example"><span class="math_symbol">&#8704;</span> A. A is SET. <span class="math_symbol">&#8707;</span> S. <span class="math_symbol">&#8707;</span> Q. A <span class="math_symbol">&#8712;</span> O. A <span class="math_symbol">&#8866;</span> next_scope(A, S, Q) <span class="math_symbol">&#8658;</span> S <span class="math_symbol">&#8838;</span> Q.</p><p class="">Definitions for <span class="example"> new_scope</span> are given below.</p><p class=""><span class="example"> scope</span> is a function from a grammar element and a set of variables in scope to true or false. It is defined for each grammar element in O.</p><p class="example"><span class="math_symbol">&#8704;</span> A. <span class="math_symbol">&#8707;</span> S. A <span class="math_symbol">&#8712;</span> O. A <span class="math_symbol">&#8866;</span> scope(A, S)</p><p class="">Definitions for <span class="example"> scope</span> are given below.</p><p class="">Definitions follow:</p><p class="">If all the members of set are syntactic elements, with a <span class="example"> next_scope</span> rule then the set has correct scoping when all of its members have correct scoping in the context of some scoping set.</p><p class="example"><span class="math_symbol">&#8707;</span> D. D <span class="math_symbol">&#8712;</span> O.  D is SET. 
<span class="math_symbol">&#8704;</span> A. A <span class="math_symbol">&#8712;</span> D. 
<span class="math_symbol">&#8707;</span> S. 
<span class="math_symbol">&#8707;</span> Q.  
next_scope(A, S, Q).  
scope(D, S) <span class="math_symbol">&#8660;</span> scope(A, Q)</p><p class="">Hence a program P only has correct scoping when its elements have correct scoping:</p><p class="example"><span class="math_symbol">&#8704;</span> A. A <span class="math_symbol">&#8712;</span> P. next_scope(P, S, Q). scope(A, Q) <span class="math_symbol">&#8660;</span> scope(P, S)</p><p class="">A function definition <span class="example"> F</span> only has correct scoping when the set of its where clause constants <span class="example"> Wc</span> have correct scoping and the set of its where clause function definitions <span class="example"> Wf</span> have correct scopping and its block <span class="example"> Fb</span> has correct scoping.</p><p class="example"><span class="math_symbol">&#8704;</span>&nbsp;F.&nbsp;F&nbsp;is&nbsp;FUNCTIONDEFINITION.&nbsp;<br /><span class="math_symbol">&#8707;</span>&nbsp;FB.&nbsp;Fb&nbsp;<span class="math_symbol">&#8712;</span>&nbsp;F.&nbsp;Fb&nbsp;is&nbsp;BLOCK.&nbsp;<br /><span class="math_symbol">&#8707;</span>&nbsp;Wh.&nbsp;Wh&nbsp;<span class="math_symbol">&#8712;</span>&nbsp;F.&nbsp;Wh&nbsp;is&nbsp;SET.&nbsp;<span class="math_symbol">&#8704;</span>&nbsp;G.&nbsp;G&nbsp;<span class="math_symbol">&#8712;</span>&nbsp;Wh.&nbsp;G&nbsp;is&nbsp;DEFINITION.&nbsp;&nbsp;<br /><span class="math_symbol">&#8707;</span>&nbsp;A.&nbsp;A&nbsp;is&nbsp;FORMALARGUMENTS.&nbsp;Sa&nbsp;:=&nbsp;A&nbsp;<span class="math_symbol">&#8746;</span>&nbsp;S.&nbsp;<br /><span class="math_symbol">&#8707;</span>&nbsp;Bq.&nbsp;new_scope(Fb,&nbsp;Sa,&nbsp;Bq).&nbsp;&nbsp;<br /><span class="math_symbol">&#8707;</span>&nbsp;Whq.&nbsp;new_scope(Wh,&nbsp;Sa,&nbsp;Whq).&nbsp;<br />scope(F,&nbsp;S)&nbsp;<span class="math_symbol">&#8660;</span>&nbsp;scope(Fb,&nbsp;Bq)&nbsp;<span class="math_symbol">&#8743;</span>&nbsp;scope(Wh,&nbsp;Whq)</p><p class=""><span class="example"> next_scope</span> for a where clause definition is the union of the old scope with the names of the where clause's function definitions.</p><p class="example">forall&nbsp;Wf.&nbsp;&nbsp;Wf&nbsp;subset&nbsp;Wh.&nbsp;&nbsp;forall&nbsp;F.&nbsp;F&nbsp;member&nbsp;Wf.&nbsp;F&nbsp;is&nbsp;FUNCTIONDEFINITION.&nbsp;<br />new_scope(Wh,&nbsp;S,&nbsp;Whq)&nbsp;iff&nbsp;Whq&nbsp;=&nbsp;Wf&nbsp;union&nbsp;S.</p><p class=""><span class="example"> next_scope</span> for a block <span class="example"> Fb</span> is derived from the block's where clause <span class="example"> Wh</span></p><p class="example"><span class="math_symbol">&#8707;</span>&nbsp;S.&nbsp;<span class="math_symbol">&#8707;</span>&nbsp;Bs.&nbsp;<br /><span class="math_symbol">&#8707;</span>&nbsp;B.&nbsp;B&nbsp;is&nbsp;BLOCK.&nbsp;<br /><span class="math_symbol">&#8707;</span>&nbsp;Wh.&nbsp;Wh&nbsp;<span class="math_symbol">&#8712;</span>&nbsp;B.&nbsp;Wh&nbsp;is&nbsp;WHERECLAUSE.&nbsp;<br />new_scope(B,&nbsp;S,&nbsp;Bs)&nbsp;<span class="math_symbol">&#8660;</span>&nbsp;Bs&nbsp;=&nbsp;S&nbsp;<span class="math_symbol">&#8746;</span>&nbsp;Wh</p><p class="">A block associates a set of expressions with a where clause.</p><p class="example"><span class="math_symbol">&#8707;</span>&nbsp;S.&nbsp;<br /><span class="math_symbol">&#8704;</span>&nbsp;B.&nbsp;B&nbsp;is&nbsp;BLOCK.&nbsp;new_scope(B,&nbsp;S,&nbsp;Bs).&nbsp;<br /><span class="math_symbol">&#8707;</span>&nbsp;Be.&nbsp;<span class="math_symbol">&#8704;</span>&nbsp;E.&nbsp;Be&nbsp;<span class="math_symbol">&#8712;</span>&nbsp;B.&nbsp;E&nbsp;<span class="math_symbol">&#8712;</span>&nbsp;Be.&nbsp;E&nbsp;is&nbsp;EXPRESSION.&nbsp;<br /><span class="math_symbol">&#8707;</span>&nbsp;Wh.&nbsp;Wh&nbsp;<span class="math_symbol">&#8712;</span>&nbsp;B.&nbsp;Wh&nbsp;is&nbsp;WHERECLAUSE.&nbsp;<br /><span class="math_symbol">&#8707;</span>&nbsp;Bl.&nbsp;<span class="math_symbol">&#8707;</span>&nbsp;Whq.&nbsp;new_scope(Wh,&nbsp;S,&nbsp;Whq).&nbsp;<br />scope(B,&nbsp;S)&nbsp;<span class="math_symbol">&#8660;</span>&nbsp;scope(E,&nbsp;Bs)&nbsp;<span class="math_symbol">&#8743;</span>&nbsp;scope(Wh,&nbsp;Whq)</p><p class="">Following are the rules for the different kinds of expression:</p><p class="">For an identifier I to be in scope, the string making up that identifier must be a member of the scoping set S.</p><p class="example"><span class="math_symbol">&#8704;</span>&nbsp;I.&nbsp;I&nbsp;is&nbsp;IDENTIFIER.&nbsp;&nbsp;<br /><span class="math_symbol">&#8707;</span>&nbsp;S.&nbsp;<br />I&nbsp;<span class="math_symbol">&#8712;</span>&nbsp;S&nbsp;<span class="math_symbol">&#8660;</span>&nbsp;scope(I,&nbsp;S)</p><p class="">Literal values (numbers, characters etc) are always in scope.</p><p class="example"><span class="math_symbol">&#8704;</span> N. N is LITERAL. <span class="math_symbol">&#8704;</span> S. scope(I,S)</p><p class="">If statements can be considered sets, as they are non-terminal and introduce no new identifiers into the scope. Hence they can be handled as per sets above.</p><p class="">Applications, both infix and prefix can be considered sets of expressions, for the same reasons, hence are handled as for sets above</p><h2 class="banner"><a name="type">3.1.2. Type Unification</a></h2><p class="stage">The <a href="Language/Obelisk/TypeChecker.hs"> type checker</a> attempts type unification.</p><p class="">The process of determining if an Obelisk program exhibits type unification is described here.</p><p class="">An Obelisk program with unifying types has the following properties when <a href="#eval"> evaluated</a>:</p><p class="">* The program can never crash due to the Obelisk <a href="#eval"> run-time environment</a> receiving unexpected data.  For example, a function provided as part of an Obelisk implementation which takes a Character for an argument will not be given an Integer as an argument.</p><p class="">As can be seen in the <a href="#grammar"> grammar</a>, types come in two varieties:</p><p class="">* A function type.</p><p class="">* A simple type.</p><p class="">A function type is a set of types.</p><p class="example"><span class="math_symbol">&#8704;</span>&nbsp;T.&nbsp;T&nbsp;is&nbsp;FUNCTIONTYPE.&nbsp;<br /><span class="math_symbol">&#8704;</span>&nbsp;Q.&nbsp;Q&nbsp;<span class="math_symbol">&#8712;</span>&nbsp;T.&nbsp;Q&nbsp;is&nbsp;TYPE</p><p class="">A relationship exists between a function type <span class="example"> T</span> and a natural number <span class="example"> I</span>, where I is the number of the arguments expected by the function described by the type.</p><p class="example"><span class="math_symbol">&#8704;</span>&nbsp;T.&nbsp;T&nbsp;is&nbsp;FUNCTIONTYPE.&nbsp;<br /><span class="math_symbol">&#8707;</span>&nbsp;I.&nbsp;I&nbsp;<span class="math_symbol">&#8712;</span>&nbsp;N.&nbsp;<br />type_arg_count(T,&nbsp;N).</p><p class="">A relationship exists between a function type <span class="example"> T</span> and its return type <span class="example"> Q</span></p><p class="example"><span class="math_symbol">&#8704;</span>&nbsp;T.&nbsp;T&nbsp;is&nbsp;FUNCTIONTYPE.&nbsp;<br /><span class="math_symbol">&#8707;</span>&nbsp;Q.&nbsp;Q&nbsp;<span class="math_symbol">&#8712;</span>&nbsp;T.&nbsp;Q&nbsp;is&nbsp;RETURNTYPE.&nbsp;<br />return(T,&nbsp;Q).</p><p class="">A relationship exists between a function type <span class="example"> T</span> and the types of its arguments <span class="example"> A</span></p><p class="example"><span class="math_symbol">&#8704;</span>&nbsp;T.&nbsp;T&nbsp;is&nbsp;FUNCTIONTYPE.&nbsp;<br /><span class="math_symbol">&#8704;</span>&nbsp;Q.&nbsp;<span class="math_symbol">&#8712;</span>&nbsp;T.&nbsp;Q&nbsp;is&nbsp;ARGUMENT.&nbsp;<br />Qs&nbsp;:=&nbsp;[Q].&nbsp;<br />type_args(T,&nbsp;Qs)</p><p class=""><span class="example"> typeof</span> is a relationship between an AST element <span class="example"> A</span>, its type environment <span class="example"> E</span>, and its type <span class="example"> T</span>.  The type environment <span class="example"> E</span> is a set of associations between identifiers and types.</p><p class="example"><span class="math_symbol">&#8704;</span>&nbsp;A.&nbsp;A&nbsp;<span class="math_symbol">&#8712;</span>&nbsp;O.&nbsp;<br /><span class="math_symbol">&#8704;</span>&nbsp;E.&nbsp;E&nbsp;is&nbsp;SET.&nbsp;<br /><span class="math_symbol">&#8707;</span>&nbsp;T.&nbsp;T&nbsp;is&nbsp;TYPE.&nbsp;<br />A&nbsp;<span class="math_symbol">&#8866;</span>&nbsp;typeof(A,&nbsp;E,&nbsp;T)</p><p class="">A relationship <span class="example"> new_env(A, E, N)</span> exists between some AST elements <span class="example"> A</span>, a type environment <span class="example"> E</span>, and a new type environment <span class="example"> N</span>.</p><p class="example"><span class="math_symbol">&#8707;</span>&nbsp;A.&nbsp;A&nbsp;<span class="math_symbol">&#8712;</span>&nbsp;O.&nbsp;<br /><span class="math_symbol">&#8704;</span>&nbsp;E.&nbsp;E&nbsp;is&nbsp;SET.&nbsp;<br /><span class="math_symbol">&#8707;</span>&nbsp;N.&nbsp;N&nbsp;is&nbsp;SET.&nbsp;<br />A&nbsp;<span class="math_symbol">&#8866;</span>&nbsp;new_env(A,&nbsp;E,&nbsp;N)&nbsp;<span class="math_symbol">&#8658;</span>&nbsp;E&nbsp;<span class="math_symbol">&#8838;</span>&nbsp;N</p><p class="">A relationship exists between some AST elements <span class="example"> A</span> and a type <span class="example"> T</span>, when <span class="example"> A</span> has had a type declared (definitions).</p><p class="example"><span class="math_symbol">&#8704;</span>&nbsp;A.&nbsp;A&nbsp;<span class="math_symbol">&#8712;</span>&nbsp;O.&nbsp;A&nbsp;is&nbsp;DEFINITION.&nbsp;<span class="math_symbol">&#8707;</span>&nbsp;T.&nbsp;T&nbsp;is&nbsp;TYPE.&nbsp;<br />A&nbsp;<span class="math_symbol">&#8866;</span>&nbsp;declared(A,&nbsp;T)</p><p class="">If an AST element <span class="example"> A</span> is a set of other AST elements, and one of its members <span class="example"> B</span> has the type <span class="example"> <span class="math_symbol">&#8869;</span></span>, then the type of <span class="example"> A</span> is also <span class="example"> <span class="math_symbol">&#8869;</span></span></p><p class="example"><span class="math_symbol">&#8704;</span>&nbsp;A.&nbsp;A&nbsp;<span class="math_symbol">&#8712;</span>&nbsp;O.&nbsp;A&nbsp;is&nbsp;SET.&nbsp;<br /><span class="math_symbol">&#8704;</span>&nbsp;E.&nbsp;E&nbsp;is&nbsp;SET.&nbsp;<br /><span class="math_symbol">&#8707;</span>&nbsp;N.&nbsp;N&nbsp;is&nbsp;SET.&nbsp;<br /><span class="math_symbol">&#8707;</span>&nbsp;B.&nbsp;B&nbsp;<span class="math_symbol">&#8712;</span>&nbsp;A.&nbsp;B&nbsp;<span class="math_symbol">&#8712;</span>&nbsp;O.&nbsp;<br />new_env(A,&nbsp;E,&nbsp;B).&nbsp;<br />typeof(B,&nbsp;N,&nbsp;<span class="math_symbol">&#8869;</span>)&nbsp;<span class="math_symbol">&#8658;</span>&nbsp;typeof(A,&nbsp;E,&nbsp;<span class="math_symbol">&#8869;</span>)</p><p class="">Hence, an Obelisk program <span class="example"> P</span> exhibits type unification when none of its elements has <span class="example"> <span class="math_symbol">&#8869;</span></span> for a type:</p><p class="example"><span class="math_symbol">&#8704;</span>&nbsp;A.&nbsp;A&nbsp;<span class="math_symbol">&#8712;</span>&nbsp;P.&nbsp;<br /><span class="math_symbol">&#8704;</span>&nbsp;N.&nbsp;N&nbsp;is&nbsp;SET.&nbsp;<br />new_env(A,&nbsp;<span class="math_symbol">&#8709;</span>,&nbsp;N).&nbsp;<br />typeof(A,&nbsp;N,&nbsp;<span class="math_symbol">&#8869;</span>)&nbsp;<span class="math_symbol">&#8660;</span>&nbsp;typeof(P,&nbsp;E,&nbsp;<span class="math_symbol">&#8869;</span>)</p><p class="">There is a relationship between a function definition <span class="example"> F</span> and the number of formal arguments <span class="example"> I</span> expected by that function.</p><p class="example"><span class="math_symbol">&#8704;</span>&nbsp;F.&nbsp;F&nbsp;is&nbsp;FUNCTIONDEFINITION.&nbsp;<br /><span class="math_symbol">&#8707;</span>&nbsp;I.&nbsp;I&nbsp;<span class="math_symbol">&#8712;</span>&nbsp;N.&nbsp;<br />fargs(F,&nbsp;I)</p><p class="">A Function definition <span class="example"> F</span> exhibits type unification when its where clause <span class="example"> Wh</span> and its block <span class="example"> Bl</span> exhibit type unification, when the number of its formal arguments is equal to the number of arguments expected by its type, and when return value of its type is of the same type as the type of the block.</p><p class="example"><span class="math_symbol">&#8704;</span>&nbsp;F.&nbsp;F&nbsp;is&nbsp;FUNCTIONDEFINITION.&nbsp;<br /><span class="math_symbol">&#8707;</span>&nbsp;E.&nbsp;E&nbsp;is&nbsp;SET.&nbsp;<br /><span class="math_symbol">&#8707;</span>&nbsp;Fas.&nbsp;type_args(F,&nbsp;Fas).&nbsp;<br />Ea&nbsp;:=&nbsp;E&nbsp;<span class="math_symbol">&#8746;</span>&nbsp;Fas.&nbsp;<br /><span class="math_symbol">&#8707;</span>&nbsp;Bl.&nbsp;Bl&nbsp;is&nbsp;BLOCK.&nbsp;<br /><span class="math_symbol">&#8707;</span>&nbsp;Ble.&nbsp;new_env(Bl,&nbsp;Ea,&nbsp;Ble).&nbsp;<br /><span class="math_symbol">&#8707;</span>&nbsp;Wh.&nbsp;Wh&nbsp;is&nbsp;WHERECLAUSE.&nbsp;<br /><span class="math_symbol">&#8707;</span>&nbsp;Whe.&nbsp;new_env(Wh,&nbsp;Ea,&nbsp;Whe).&nbsp;<br /><span class="math_symbol">&#8707;</span>&nbsp;D.&nbsp;declared(F,&nbsp;D).&nbsp;<br /><span class="math_symbol">&#8707;</span>&nbsp;T.&nbsp;typeof(F,&nbsp;E,&nbsp;T).&nbsp;<br /><span class="math_symbol">&#8707;</span>&nbsp;Q.&nbsp;typeof(Bl,&nbsp;Ble,&nbsp;Q).&nbsp;<br /><span class="math_symbol">&#8707;</span>&nbsp;I.&nbsp;fargs(F,&nbsp;I).&nbsp;<br /><span class="math_symbol">&#8707;</span>&nbsp;J.&nbsp;type_arg_count(D,&nbsp;J).&nbsp;<br /><span class="math_symbol">&#8707;</span>&nbsp;R.&nbsp;return(D,&nbsp;R).&nbsp;<br />Q&nbsp;=&nbsp;<span class="math_symbol">&#8869;</span>&nbsp;<span class="math_symbol">&#8658;</span>&nbsp;T&nbsp;=&nbsp;<span class="math_symbol">&#8869;</span>&nbsp;<span class="math_symbol">&#8744;</span>&nbsp;&nbsp;<br />typeof(Wh,&nbsp;Whe,&nbsp;<span class="math_symbol">&#8869;</span>)&nbsp;<span class="math_symbol">&#8658;</span>&nbsp;T&nbsp;=&nbsp;<span class="math_symbol">&#8869;</span>&nbsp;<span class="math_symbol">&#8744;</span>&nbsp;<br />I&nbsp;<span class="math_symbol">&#8800;</span>&nbsp;j&nbsp;<span class="math_symbol">&#8658;</span>&nbsp;T&nbsp;=&nbsp;<span class="math_symbol">&#8869;</span>&nbsp;<span class="math_symbol">&#8744;</span>&nbsp;<br />Q&nbsp;<span class="math_symbol">&#8800;</span>&nbsp;R&nbsp;<span class="math_symbol">&#8658;</span>&nbsp;T&nbsp;=&nbsp;<span class="math_symbol">&#8869;</span>&nbsp;<span class="math_symbol">&#8744;</span>&nbsp;<br />Q&nbsp;=&nbsp;R&nbsp;<span class="math_symbol">&#8660;</span>&nbsp;T&nbsp;=&nbsp;D</p><p class="">The new type environment associated with a where clause <span class="example"> Wh</span> is formed by the addition of the types of the where clause's functions</p><p class="example"><span class="math_symbol">&#8707;</span>&nbsp;Wh.&nbsp;Wh&nbsp;is&nbsp;WHERECLAUSE.&nbsp;<br /><span class="math_symbol">&#8704;</span>&nbsp;Whf.&nbsp;Whf&nbsp;<span class="math_symbol">&#8712;</span>&nbsp;Wh.&nbsp;Whf&nbsp;is&nbsp;FUNCTION&nbsp;DEFINITION.&nbsp;<br /><span class="math_symbol">&#8707;</span>&nbsp;E.&nbsp;<br /><span class="math_symbol">&#8707;</span>&nbsp;Whe.&nbsp;<br />new_env(Wh,&nbsp;E,&nbsp;Whe)&nbsp;<span class="math_symbol">&#8660;</span>&nbsp;Whe&nbsp;=&nbsp;E&nbsp;<span class="math_symbol">&#8746;</span>&nbsp;Whe</p><p class="">A where clause constant <span class="example"> Wc</span> exhibits type unification when its declared type <span class="example"> D</span>  is the same as the type <span class="example"> Q</span> of its expression <span class="example"> E</span>.</p><p class="example"><span class="math_symbol">&#8707;</span>&nbsp;Wc.&nbsp;Wc&nbsp;is&nbsp;CONSTANTDEFINITION.&nbsp;<br /><span class="math_symbol">&#8707;</span>&nbsp;E.&nbsp;E&nbsp;<span class="math_symbol">&#8712;</span>&nbsp;Wc.&nbsp;W&nbsp;is&nbsp;EXPRESSION.&nbsp;<br /><span class="math_symbol">&#8707;</span>&nbsp;We.&nbsp;<span class="math_symbol">&#8707;</span>&nbsp;Q.&nbsp;typeof(E,&nbsp;We,&nbsp;Q).&nbsp;<br /><span class="math_symbol">&#8707;</span>&nbsp;D.&nbsp;declared(Wc,&nbsp;D).&nbsp;<br /><span class="math_symbol">&#8707;</span>&nbsp;T.&nbsp;typeof(Wc,&nbsp;E,&nbsp;T).&nbsp;<br />Q&nbsp;=&nbsp;<span class="math_symbol">&#8869;</span>&nbsp;<span class="math_symbol">&#8658;</span>&nbsp;T&nbsp;=&nbsp;<span class="math_symbol">&#8869;</span>&nbsp;<span class="math_symbol">&#8744;</span>&nbsp;<br />Q&nbsp;<span class="math_symbol">&#8800;</span>&nbsp;D&nbsp;<span class="math_symbol">&#8658;</span>&nbsp;T&nbsp;=&nbsp;<span class="math_symbol">&#8869;</span>&nbsp;<span class="math_symbol">&#8744;</span>&nbsp;<br />Q&nbsp;=&nbsp;D&nbsp;<span class="math_symbol">&#8660;</span>&nbsp;T&nbsp;=&nbsp;D</p><p class="">There is a relationship between an application <span class="example"> E</span> and the number of actual arguments used <span class="example"> I</span>.</p><p class="example"><span class="math_symbol">&#8707;</span>&nbsp;E.&nbsp;E&nbsp;is&nbsp;APPLICATION.&nbsp;<br /><span class="math_symbol">&#8707;</span>&nbsp;I.&nbsp;I&nbsp;<span class="math_symbol">&#8712;</span>&nbsp;N.&nbsp;<br />actual_arg_count(E,&nbsp;I)</p><p class="">There is a relationship between an application <span class="example"> E</span> and the types of its actual arguments <span class="example"> Ats</span>.</p><p class="example"><span class="math_symbol">&#8707;</span>&nbsp;E.&nbsp;E&nbsp;is&nbsp;APPLICATION.&nbsp;<br /><span class="math_symbol">&#8704;</span>&nbsp;A.&nbsp;A&nbsp;<span class="math_symbol">&#8712;</span>&nbsp;E.&nbsp;A&nbsp;is&nbsp;ACTUALARGUMENT.&nbsp;<br />Ats&nbsp;:=&nbsp;<span class="math_symbol">&#8704;</span>&nbsp;At.&nbsp;typeof(A,&nbsp;V,&nbsp;At).&nbsp;[At].&nbsp;<br />actual_args(E,&nbsp;Ats)</p><p class="">There is a relationship between an actual argument and the number of the actual argument (The first applied, the second applied, etc).</p><p class="example"><span class="math_symbol">&#8707;</span>&nbsp;A.&nbsp;A&nbsp;is&nbsp;ACTUALARGUMENT&nbsp;<br /><span class="math_symbol">&#8707;</span>&nbsp;I.&nbsp;I&nbsp;<span class="math_symbol">&#8712;</span>&nbsp;N.&nbsp;<br />actual_arg_num(A,&nbsp;I)</p><p class="">There is a relationship between a type argument and the number of the argument (The first applied, the second applied, etc).</p><p class="example"><span class="math_symbol">&#8707;</span>&nbsp;A.&nbsp;A&nbsp;is&nbsp;TYPEARGUMENT&nbsp;&nbsp;<br /><span class="math_symbol">&#8707;</span>&nbsp;I.&nbsp;I&nbsp;<span class="math_symbol">&#8712;</span>&nbsp;N.&nbsp;<br />type_arg_num(A,&nbsp;I)</p><p class="">An application <span class="example"> E</span> exhibits type unification when the applicee <span class="example"> P</span> and the actual arguments <span class="example"> A</span> exhibit type unification,  and the number of actual arguments is equal to the number of arguments, and the types of each actual argument are equal to the matching formal argument <span class="example"> F</span>.</p><p class="example"><span class="math_symbol">&#8707;</span>&nbsp;V.&nbsp;<br /><span class="math_symbol">&#8707;</span>&nbsp;E.&nbsp;E&nbsp;is&nbsp;APPLICATION.&nbsp;<br /><span class="math_symbol">&#8707;</span>&nbsp;Et.&nbsp;typeof(E,&nbsp;V,&nbsp;Et).&nbsp;<br /><span class="math_symbol">&#8707;</span>&nbsp;P.&nbsp;P&nbsp;<span class="math_symbol">&#8712;</span>&nbsp;E.&nbsp;P&nbsp;is&nbsp;APPLICEE.&nbsp;<br /><span class="math_symbol">&#8707;</span>&nbsp;Pt.&nbsp;typeof(P,&nbsp;V,&nbsp;Pt).&nbsp;<br /><span class="math_symbol">&#8707;</span>&nbsp;R.&nbsp;return(Pt,&nbsp;R).&nbsp;<br /><span class="math_symbol">&#8704;</span>&nbsp;Fts.&nbsp;type_args(Et,&nbsp;Fts).&nbsp;<br /><span class="math_symbol">&#8704;</span>&nbsp;As.&nbsp;actual_args(E,&nbsp;As).&nbsp;<br /><span class="math_symbol">&#8704;</span>&nbsp;Fc.&nbsp;type_arg_count(Pt,&nbsp;Fc).&nbsp;<br /><span class="math_symbol">&#8704;</span>&nbsp;Ac.&nbsp;actual_arg_count(E,&nbsp;Ac).&nbsp;<br /><span class="math_symbol">&#8704;</span>&nbsp;I.&nbsp;I&nbsp;<span class="math_symbol">&#8712;</span>&nbsp;N.&nbsp;<br /><span class="math_symbol">&#8704;</span>&nbsp;A.&nbsp;A&nbsp;<span class="math_symbol">&#8712;</span>&nbsp;As.&nbsp;actual_arg_num(A,&nbsp;I).&nbsp;<br /><span class="math_symbol">&#8704;</span>&nbsp;F.&nbsp;F&nbsp;<span class="math_symbol">&#8712;</span>&nbsp;Fts.&nbsp;type_arg_num(F,&nbsp;I).&nbsp;<br />Pt&nbsp;=&nbsp;<span class="math_symbol">&#8869;</span>&nbsp;<span class="math_symbol">&#8658;</span>&nbsp;Et&nbsp;=&nbsp;<span class="math_symbol">&#8869;</span>&nbsp;<span class="math_symbol">&#8744;</span>&nbsp;&nbsp;<br /><span class="math_symbol">&#8869;</span>&nbsp;<span class="math_symbol">&#8712;</span>&nbsp;Ats&nbsp;<span class="math_symbol">&#8658;</span>&nbsp;Et&nbsp;=&nbsp;<span class="math_symbol">&#8869;</span>&nbsp;<span class="math_symbol">&#8744;</span>&nbsp;<br />Pt&nbsp;<span class="math_symbol">&#8800;</span>&nbsp;Fc&nbsp;<span class="math_symbol">&#8658;</span>&nbsp;Et&nbsp;=&nbsp;<span class="math_symbol">&#8869;</span>&nbsp;<span class="math_symbol">&#8744;</span>&nbsp;&nbsp;<br />F&nbsp;<span class="math_symbol">&#8800;</span>&nbsp;A&nbsp;<span class="math_symbol">&#8658;</span>&nbsp;Et&nbsp;=&nbsp;<span class="math_symbol">&#8869;</span>&nbsp;<span class="math_symbol">&#8744;</span>&nbsp;&nbsp;<br />Et&nbsp;=&nbsp;R</p><p class="">Infix applications behave as for prefix applications.</p><p class="">The type of a literal character is Char</p><p class="example">typeof(LITERAL_CHARACTER, Char)</p><p class="">The type of a literal integer is INT</p><p class="example">typeof(LITERAL_INTEGER, Int)</p><p class="">There is a relationship between an identifier <span class="example"> I</span>, a type <span class="example"> T</span> and a type environment <span class="example"> E</span>, whereby the identifier is associated with a type in the environment. Hence, the type of the identifier can be found.</p><p class="example"><span class="math_symbol">&#8704;</span>&nbsp;I.&nbsp;I&nbsp;is&nbsp;IDENTIFIER.&nbsp;<br /><span class="math_symbol">&#8707;</span>&nbsp;E.&nbsp;<br /><span class="math_symbol">&#8707;</span>&nbsp;T.&nbsp;T&nbsp;is&nbsp;TYPE.&nbsp;T&nbsp;<span class="math_symbol">&#8712;</span>&nbsp;E.&nbsp;<br />typeof(I,&nbsp;E,&nbsp;T)</p></body></html>