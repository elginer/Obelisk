<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/> 
      <title>The Obelisk Programming Language</title>
      <style type="text/css">
      .code {background-color: #222222; font-size: x-large; font-family: monospace; color: yellow;}
      .banner {text-align: center;}
      .boring {font-family: monospace; font-size: x-large;}
      div.columnholder {width: 100%; height: 200px;}
      div.column {border: 2px solid yellow; width: 500px; float: left; height: 200px;}
      body {font-family: sans-serif;}
      </style>
   </head>
   <body>
      <h1 class="banner">The Obelisk Programming Language Report</h1>
      <h2 class="banner">Copyright John Morrice 2010.  Contact: spoon@killersmurf.com</h2>
      <h3 class="banner">Released under the terms of the GNU GPL-3.  See the file 'LICENCE'.</h3>
      <p class="boring">
         The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and "OPTIONAL" in this document are to be interpreted as described in <a href="http://www.ietf.org/rfc/rfc2119.txt">RFC 2119</a>.
      </p>
      <p>
         Obelisk is a general purpose systems programming language.
         <br/><br/>
         Obelisk aims to:
         <br/>Have an expressive type system, but be utterly type-safe.
         <br/>Respect functional purity, with no mutable variables in functions...
         <br/>...but also to support class-based objects that control the mutable state represented by their instance variables.
         <br/>Be native-code compiling, for speed.
         <br/>Have a robust development methodology. Everything must be tested rigorously because programmers cry when their code-generators break.  
      </p>
      <p><b>Contents:</b>
         <br/>
         &nbsp;&nbsp;&nbsp;<a href="#intro">1. Introduction</a><br/>
         &nbsp;&nbsp;&nbsp;<a href="#syntax">2. Syntax</a><br/>
         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#lexicalsyntax">2.1 Lexical syntax</a><br/>
         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#reservedwords">2.1.1 Reserved words</a><br/>
         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#syntaxproper">2.2 Syntax proper</a><br/>
         &nbsp;&nbsp;&nbsp;<a href="#semantics">3. Semantics</a><br/>
         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#scope">3.1 Scoping rules</a><br/>
         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#types">3.2 Types</a><br/>
         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#evaluation">3.3 Evaluation</a><br/>
         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#application">3.3.1 Application</a><br/>
         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#fapplication">3.3.1.1 Function application</a><br/>
         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#oapplication">3.3.1.2 Operator application</a><br/>
         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tailcall">3.3.1.3 Tail-call optimization</a><br/>
         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#functions">3.3.2 Functions</a><br/>
         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#operators">3.3.3 Operators</a><br/>
         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#blocks">3.3.4 Blocks</a><br/>
         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#if">3.3.5 If statement</a><br/>
         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#whereclause">3.3.6 Where clause</a><br/>
         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#constants">3.3.6.1 Constants</a><br/>
         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#functions_where">3.3.6.2 Functions defined within a where clause</a><br/>
         
      </p>
      <h1>1. Introduction</h1>
      <p>
         This file is a report on the current state of the Obelisk programming language.  It describes a standard which compliant Obelisk implementations MUST meet.  The Obelisk Compiler is the name of a free compiler which implements this standard.<br/><br/>


         This report is structured as the Obelisk compiler:  each stage in compilation process is described, and in the order of execution of The Obelisk compiler.<br/><br/>
         
         This means that at first the lexical rules are described (associated with lexical analysis), before moving on to describe the syntax (associated with parsing, after lexical analysis in the compiler chain), and so on, for all stages of the compiler, or equivalently with all aspects of the Obelisk programming language.<br/><br/>

         The advantage this approach is that each subsection can be analysed with respect to a single compiler subsystem.  So if you are confused, or you suspect the a subsection of this report to be at odds with the behaviour of the compiler, you can easily find code which represents that subsection and find clarification.<br/><br/>

         In aid to that, links to files within appropriate subsystems of The Obelisk Compiler can be found in italics at the beginning of every subsection.
      </p>
      <h1> 
         <a name="syntax">
            2. Syntax
         </a>
      </h1>
      <h2>
         <a name="lexicalsyntax">
            2.1 Lexical syntax
         </a>
      </h2>
      <p>
         <i>Lexical syntax is associated with the <a href="Language/Obelisk/Lexer.hs">lexer</a>.</i>
      </p>
      <p>
         Before parsing, Obelisk source undergoes lexical analysis where comments and whitespace are removed.  The legal tokens are then parsed as set out in <a href="#syntaxproper">section 2.2 Syntax proper</a>.<br/><br/>
         Whitespace consists of the space character, aswell as the following characters, represented here by their escape codes:
      </p>
      <p class="code">
         \n\t\r
      </p>
      <p>
         Obelisk supports both line and block comments.<br/><br/>
         Line comments are started by the token <span class="code">//</span> and last until the next newline.<br/><br/>
         Block comments are started by the token <span class="code">/*</span> and last until the token <span class="code">*/</span>.  Block comments in Obelisk are not nested.<br/><br/>
         Here is an example lexical analysis parse.  The left column represents source* prior to lexical analysis.  The right hand side represents source after lexical analysis.<br/><br/>
      </p>
      <div class="columnholder">
         <div class="column code">
            <p>
               // I say, you look very gruntled Jeeves!
               <br/>
               <br/>
               ((Void) # def functional programming<br/>
               &nbsp;&nbsp;&nbsp;((is fun)))
               <br/>
               <br/>
               /* That was a bit pointless
               <br/>
               &nbsp;&nbsp;&nbsp;but hey ho, it was just an example! */<br/>
            </p>
         </div>
         <div class="column code">
            <p>
               ((Void) # def functional programming ((is fun)))
            </p>
         </div>
      </div>
      <h2>
         <a name="reservedwords">
            2.1.1 Reserved words
         </a>
      </h2>
      <p>
         Reserved words are identified during lexical analysis.  These reserved words are:
      </p>
      <p class="code">
         op<br/><br/>
         def<br/><br/>
         where<br/><br/>
         let<br/><br/>
         true<br/><br/>
         false<br/><br/>
         if<br/><br/>
         #<br/><br/>
         -&gt;
      </p>
      <h2>
         <a name="syntaxproper">
            2.2 Syntax proper
         </a>
      </h2>
      <p>
         <i>Obelisk's syntax is described by this <a href="happy/obelisk.y">happy file.</a></i>
      </p>
      <p>
         Following is the syntax of Obelisk in pseudo bnf.  Text within apostrophes is <span class="code">'literal'</span>. <span class="code">#</span> indicates a comment till the end of line.  Curly brackets enclose optional elements, eg <span class="code">{ exercise }</span>.  Backslashes enclose a perl-style regular expression, eg <span class="code">/(wub)+/</span>. A pipe <span class="code">|</span> seperates alternatives.
      </p>
      <p class="code">
         # The source is a list of definitions<br/>
         obelisk: fdef obelisk | fdef<br/><br/>

         # A function definition<br/>
         fdef: '(' '(' ftype ')' 'def' vars block where_clause ')'<br/><br/>

         # A function's type<br/>
         ftype: classname | ftype '-&gt;' classname <br/><br/>

         # A list of definitions<br/>
         defs: def defs | def <br/><br/>

         # definitions are either a function...<br/>
         def: fdef<br/>
            &nbsp;&nbsp;&nbsp;| # or a constant<br/>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'(' stype 'let' var exp ')' <br/><br/>

         # A simple type<br/>
         stype: classname<br/><br/>

         # A list of expressions<br/>
         exps: exp exps | exp <br/><br/>

         # An expression, to be evaluated at runtime<br/>
         exp: if | integer | var | '(' vars ')' | '(' exp operator exp ')' | 'true' | 'false'<br/><br/>

         # An if statement.<br/>
         if:  'if' exp block block<br/><br/>

         # A block of code<br/>
         block: '(' { exps } where_clause ')'<br/><br/>

         # A where clause, allowing definitions within a function or block.
         where_clause: { 'where' '(' { defs } ')' }

         # A list of variables <br/>
         vars: var+<br/><br/>

         # A variable is one lower case letter followed by zero or more alphanumeric characters or the ? or _ characters.<br/>
         var: /[a-z]([a-z]|[A-z]|[0-9]|_|?)*/<br/><br/>

         # An integer<br/>
         integer: /[0-9]+/<br/><br/>

         # A classname is an upper case letter followed by zero or more alphanumeric characters<br/>
         classname: /[A-Z]([a-z]|[A-z]|[0-9])*/
             
      </p>

      <p>Here is an example of a valid program, to give a concrete example of syntax use.</p>
      <p class="code">
         // An accumulating implementation of the factorial function.  Tail recursive.<br/>
         ((Int -&gt; Int) #<br/>
         def factorial x <br/>
         &nbsp;&nbsp;&nbsp;((fact 1 x))<br/>
         &nbsp;&nbsp;&nbsp;where<br/>
         &nbsp;&nbsp;&nbsp;((Int -&gt; Int -&gt; Int #<br/>
         &nbsp;&nbsp;&nbsp;def fact acc i<br/>
         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((if (i &gt; 0)<br/>
         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((fact (i * acc) (i - 1)))<br/>
         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(acc))))))
      </p>
      <h1>
         <a name="semantics">
            3. Semantics
         </a>
      </h1>
      <p>
         The following sections describe in detail the semantics of the Obelisk.<br/><br/>
         This section attempts to briefly summerise Obelisk's semantics using common computer science jargon, and examples comparing Obelisk to the <a href="http://cm.bell-labs.com/cm/cs/cbook/">C programming languge.</a><br/><br/>
         To get the computer to 'do' something in C, a <a href="#functions">function</a> must be <a href="#fapplication">applied</a> to zero or more arguments.  The same is true for Obelisk, but the syntax is different.  In Obelisk:
      </p>
      <p class="code">
         // Call function foo with arguments bar and baz<br/>
         (foo bar baz)
      </p>
      <p>
         In C:
      </p>
      <p class="code">
         /* Call function foo with arguments bar and baz. */<br/>
         foo(bar baz);
      </p>
      <p>
         New functions are defined using the reserved word <span class="code">def</span>.  Importantly, Obelisk functions benefit from <a href="#tailcall">tail-call optimization</a> meaning that calling foo here will not blow the stack:
      </p>
      <p class="code">
         // Mutually recursive functions call each other without growing the stack.<br/>
         ((Void) #<br/>
         def foo ((bar)))<br/>
         <br/>
         ((Void) #<br/>
         def bar ((foo)))
      </p>
      <p>
         The C version would grow the stack indefinately until the program crashed:
      </p>
      <p class="code">
      /* Mutually recursive functions call each other, growing the stack.*/<br/>
      void foo()<br/>
      {<br/>
      &nbsp;&nbsp;&nbsp;bar();<br/>
      }<br/>
      <br/>
      void bar()<br/>
      {<br/>
      &nbsp;&nbsp;&nbsp;foo();<br/>
      }
      </p>
      <p>
         In Obelisk, <a href="#functions_where">inner function definitions</a> and <a href="#constants">constants</a> are declared in where clause, which is located either at the end of a function definition, or at the end of a <a href="#blocks">block.</a>  To be more robust, Obelisk takes inspiration from the pure functional language Haskell and hence functions have no variables:  the value of a constant cannot change once it is defined!<br/>
      </p>
      <p class="code">
         // An Obelisk function defining constants within where clauses<br/>
         ((Int -&gt; Int) #<br/>
         def foo x<br/>
         &nbsp;&nbsp;&nbsp;((if ((x &gt; 10))<br/><br/>
         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Execute this block if x &gt; 10<br/>
         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((y * x)<br/>
         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;where<br/>
         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// y is wihin the scope of the 'then' branch of the if statement.<br/> 
         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((Int # let y 10))))<br/><br/>
         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Execute this block if x &lt;= 10<br/>
         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((z * x)))<br/><br/>

         &nbsp;&nbsp;&nbsp;where<br/>
         &nbsp;&nbsp;&nbsp;// z is within the scope of the whole function<br/>
         &nbsp;&nbsp;&nbsp;((Int # let z 20)))
      </p>

      </p>
      <p>
        A comparable C function defining automatic variables:
      </p>
      <p class="code">
         /* A C function with automatic variables */<br/>
         int foo(int x)<br/>
         {<br/>
         &nbsp;&nbsp;&nbsp;/* z is within the scope of the whole function */<br/>
         &nbsp;&nbsp;&nbsp;int z;<br/>
         &nbsp;&nbsp;&nbsp;z = 20;<br/>
         <br/> 
         &nbsp;&nbsp;&nbsp;if (x &gt; 10)<br/>
         &nbsp;&nbsp;&nbsp;/* Execute this block if x &gt; 10 */<br/>
         &nbsp;&nbsp;&nbsp;{<br/>
         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* y is within the scope of the 'then' branch of the if statement. */<br/>
         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int y;<br/>
         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = 10;<br/>
         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return y * x;<br/>
         &nbsp;&nbsp;&nbsp;}<br/>
         &nbsp;&nbsp;&nbsp;else<br/>
         &nbsp;&nbsp;&nbsp;/* Execute this block if x &lt;= 10 */<br/>
         &nbsp;&nbsp;&nbsp;{<br/>
         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return z * x;<br/>
         &nbsp;&nbsp;&nbsp;}<br/>
      }
      </p>
      <p>
         As seen in the last example, Obelisk also supports the <a href="#if">if statement</a> and <a href="#operators">infix operators</a> like + and *.
      </p>
      <h2>
         <a name="scope">
            3.1 Scope
         </a>
      </h2>
      <p>
         <i>The <a href="Language/Obelisk/Scoper.hs">scoper</a> ensures scoping rules are obeyed.</i>
      </p>
      <p>
         An obelisk source file consists of a series of top level function definitions.<br/>
         These definitions are always in scope.<br/>
      </p>
      <p class="code">
         // The functions x and y can each return the other, because they share the same scope.<br/>
         ((Void) # def x (y))<br/>
         ((Void) # def y (x))<br/>
      </p>
      <p>
         Each function definition has an optional where clause, which can introduce new functions and constants into the scope of the function.
      </p>
      <p class="code">
         // Increment an integer by 1<br/>
         ((Int -&gt; Int) # def inc1 x (y)<br/>
         &nbsp;&nbsp;&nbsp;where<br/>
         &nbsp;&nbsp;&nbsp;((Int # let y (x + 1))))
         <br/><br/>
         ((Int -&gt; Int) # def inc2 x ((incer x))<br/>
         &nbsp;&nbsp;&nbsp;where<br/>
         &nbsp;&nbsp;&nbsp;(((Int -&gt; Int) # def incer z ((z + 1)))))
      </p>
      <p>
         Function definitions within a where clause can see one another, and a constant can take the value of a function.  However, functions defined within a where clause cannot see constants (as the constants may depend on the functions for their value).
      </p>
      <p class="code">
         // These are legal<br/>
         ((Void) # def foo ()<br/>
         &nbsp;&nbsp;&nbsp;where<br/>
         &nbsp;&nbsp;&nbsp;(((Void) # def bar (baz))<br/>
         &nbsp;&nbsp;&nbsp;&nbsp;((Void) # def baz (bar))))
         <br/><br/>
         ((Void) # def foo ()<br/>
         &nbsp;&nbsp;&nbsp;where<br/>
         &nbsp;&nbsp;&nbsp;(((Int -&gt; Int) # def bar zob ((zob + 1)))<br/>
         &nbsp;&nbsp;&nbsp;&nbsp;(Int # let baz (bar 3))))
         <br/><br/>
         // This is illegal<br/>
         ((Void) # def foo ()<br/>
         &nbsp;&nbsp;&nbsp;where<br/>
         &nbsp;&nbsp;&nbsp;(((Int) # def bar (baz))<br/>
         &nbsp;&nbsp;&nbsp;&nbsp;(Int # let baz 0)))
      </p>
      <p>
         It is also illegal for a constant or function declared within a where clause to share a name either with a formal argument of the function to which the where clause belongs, or with another member of the same where clause.  Similarly, it is illegal for two top level functions to have the same name, and for a function to have two formal arguments with the same name.
      </p>
      <p class="code">
      // These are illegal<br/>
      ((Void) # def foo bar ()<br/>
      &nbsp;&nbsp;&nbsp;where<br/>
      &nbsp;&nbsp;&nbsp;((Int # let bar 0)))
      <br/><br/>
      ((Void) # def foo ()<br/>
      &nbsp;&nbsp;&nbsp;where<br/>
      &nbsp;&nbsp;&nbsp;((Int # let bar 0))<br/>
      &nbsp;&nbsp;&nbsp;&nbsp;((Void) # def bar ()))
      </p>
      <p>
         These rules ensure that there is no ambiguity in the naming of variables.
      </p>
      <h2>
         <a name="types">
            3.2 Types
         </a>
      </h2>
      <p>
         <i>The <a href="Language/Obelisk/TypeChecker.hs">typechecker</a> ensures that the rules of the type system are obeyed.</i>
      </p>
      <p>
         Obelisk is a strongly typed language and as such there are certain rules that must be obeyed as regards types.<br/><br/>
         Firstly, types must be declared before every function or constant definition.<br/><br/>
         A single type name indicates a simple data type. <br/><br/>
         A function's type is surrounded by brackets, to distinguish it as un-evaluated. It may consist of one type name indicating a function of no arguments, or number of type names seperated by '-&gt;' symbols indicating a function with arguments.  Of these types, all but the last are the types of the function's arguments, while the last is the type of the value the function returns.
      </p>
      <p class="code">
         // The code before the # symbol is the type signature.<br/>
         // This is a function of 2 arguments, an Int and a Bool.  It returns an Int.<br/>
         ((Int -&gt; Bool -&gt; Int) #<br/>
         def maybe_inc n should<br/>
         &nbsp;&nbsp;&nbsp;((if should<br/>
         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((n + m))<br/>
         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(n)))<br/>
         &nbsp;&nbsp;&nbsp;where<br/>
         &nbsp;&nbsp;&nbsp;// The constant here has the type Int.<br/>
         &nbsp;&nbsp;&nbsp;((Int # let m 1)))
      </p>
      <p>
         The type of a <a href="#block">block</a> is the type of the last expression.  If a block is empty, its type is <span class="code">Void</span>.<br/><br/>

         The return type of a <a href="#functions">function</a> is the type of its block.<br/><br/>

         A <a href="#constants">constant</a> in a <a href="#whereclause">where-clause</a> cannot have type Void.<br/><br/> 

         In <a href="#fapplication">function application</a> and <a href="#oapplication">operator application</a> the type of the each actual argument must match the type of the formal argument to which it is applied.  The overall type of this expression is the return type of the function.<br/><br/>

         In an <a href="#if">if statement</a>, <span class="code">if test (a) (b)</span> the type of <span class="code">test</span> must be <span class="code">Bool</span>.  Also, the types of <span class="code">a</span> and <span class="code">b</span> must be the same.<br/><br/>
       
         It is important to note that a function whose type is <span class="code">(A)</span> is not equivalent to <span class="code">A</span>.  For example:
      </p>
      <p class="code">
         // foo's block returns bar. foo has type (A), but bar must have type A. <br/>
         ((A) # def foo (bar)<br/>
         &nbsp;&nbsp;&nbsp;where<br/>
         &nbsp;&nbsp;&nbsp;((A # let bar (some expression))))<br/><br/>
      </p>
      <p>
         This distinguishes unevaluated functions from values - necessary for a consistent type checking system, especially with higher order functions (unimplemented).
      </p>
      <h2>
         <a name="evaluation">
            3.3 Evaluation
         </a>
      </h2>
      <p>
         <i>The <a href="Language/Obelisk/Interpreter">interpreter suite</a> is used to test that each phase of <a href="Language/Obelisk/Emitter.hs">code generation</a> preserves the semantics described here.</i>
      </p>
      <p>
         To evaluate an Obelisk program:<br/>
            Evaluate the <span class="code">main</span> <a href="#functions">function</a>,  <a href="#fapplication">applied</a> to no arguments.  Syntactically, this would look like:
      </p>
     <p class="code">
        (main)
     </p>

     <h2>
        <a name="application">
           3.3.1 Application
        </a>
     </h2>

     <p>
        There are two types of application in Obelisk: <a href="#fappliation">function application</a> and <a href="#oapplication">operator application</a>.  Both types of application MUST support tail-call optimization as described in <a href="#tailcall">3.3.1.3 Tail-call optimization</a>.
     </p>

     <h2>
        <a name="fapplication">
           3.3.1.1 Function application
        </a>
     </h2>
     <p>
        Obelisk is an eager language.  In Obelisk, the actual arguments in a function application MUST BE evaluated in left to right order.  Then the function MUST be applied to its arguments.   Execution continues as described in <a href="#functions">3.3.3 Functions</a>.
     </p>
     <p class="code">
        // First (bar) is evaluated to x, then baz is evaluated to y, then (foo x y) is evaluated<br/>
        (foo (bar) baz)
     </p>

     <h2>
        3.3.1.2 Operator application
     </h2>
     <p>
        The left argument to the operator MUST be evaluated first, then the right operator MUST be evaluated second, and finally the operator MUST be applied to its arguments.   Execution continues as described in <a href="#functions">3.3.4 Operators</a>.
     </p>
     <p class="code">
        // First (bar) is evaluated to x, then baz is evaluated to y, then (foo x y) is evaluated<br/>
        (foo (bar) baz)
     </p>

     <h2>
        <a name="tailcall">
           3.3.1.3 Tail call optimization
        </a>
     </h2>
     <p>
        If the application occurs in the context of tail call, then the application MUST NOT grow the stack.  If an implementation were to grow the stack, then that implementation would not support tail call optimization.<br/><br/>

        If the application does not occur in the context of a tail call, then the application MAY grow the stack.  However, if your implementation can run without ever growing stack, you probably deserve a medal.
     </p>

   </body>
</html>
