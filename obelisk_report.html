<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><title>The Obelisk Programming Language</title><style type="text/css">/* 
  Copyright John Morrice 2010
  This document is part of The Simple Nice-Looking Manual Generator documentation
  This document is released under the terms of the GNU Free Documentation Licence
  See the file DOC-COPYING.
*/
.intro_banner {text-align: center;}
.example
{
   font-family: monospace; 
   font-size: x-large; 
   border-style:solid; 
   border-width: 0.05em;
   padding: 0.1em;
}
body {font: arial; font-family: sans;}
.boring {font-weight: bold}
.rfc {font-family: monospace: font-size: x-large}
/* The .stage class is for text about a compilation stage */
.stage {font-style: italic;}
</style></head><body><h1 class="intro_banner">The Obelisk Programming Language</h1><h2 class="intro_banner">Copyright John Morrice 2010</h2><h2 class="intro_banner">Contact: spoon@killersmurf.com</h2><p class="boring">This document is released under the terms of the GNU Free Documentation License. See the file <a href="DOC-COPYING"> DOC-COPYING</a> for details</p><p class="rfc">The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this document are to be interpreted as described in <a href="http://www.ietf.org/rfc/rfc2119.txt"> RFC 2119</a>.</p><p class="">Obelisk is a general purpose programming language.</p><p class="">Obelisk aims to:</p><p class="">* Be an eagerly evaluated, functional programming language.</p><p class="">* Support functions with expressive, polymorphic types, but to be utterly type safe.</p><p class="">*&nbsp;Respect&nbsp;functional&nbsp;purity,&nbsp;with&nbsp;no&nbsp;mutable&nbsp;variables&nbsp;in&nbsp;functions...&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...but&nbsp;also&nbsp;to&nbsp;support&nbsp;a&nbsp;class-based&nbsp;object&nbsp;system,&nbsp;where&nbsp;objects&nbsp;control&nbsp;mutable&nbsp;state,&nbsp;represented&nbsp;by&nbsp;their&nbsp;instance&nbsp;variables</p><p class="">* Be supportive of simple and efficient implementation: implementation of an Obelisk compiler which produces competitively fast code should not warrant a PhD dissertation.</p><p class="">* Be developed in an free and open manner.</p><h2 class="contents_announce">Contents:</h2><p><a href="#intro">1. Introduction</a><br /><a href="#syntax">2. Syntax</a><br /><a href="#semantics">3. Semantics</a><br />&nbsp;&nbsp;&nbsp;<a href="#correct">3.1. Correct Programs</a><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#scope">3.1.1. Scope</a><br /></p><h2 class="banner"><a name="intro">1. Introduction</a></h2><p class="">This file is a report on the current state of the Obelisk programming language. It describes a standard which compliant Obelisk implementations MUST meet. The Obelisk Compiler is the name of a free compiler which implements this standard.  In this report The Obelisk Compiler is also referred to as 'the compiler'.</p><p class="">This report is structured as the Obelisk compiler: each stage in compilation process is described, and in the order of execution of The Obelisk compiler.</p><p class="">This means that at first the lexical rules are described (associated with lexical analysis), before moving on to describe the syntax (associated with parsing, after lexical analysis in the compiler chain), and so on, for all stages of the compiler, or equivalently with all aspects of the Obelisk programming language.</p><p class="">The advantage this approach is that each subsection can be analysed with respect to a single compiler subsystem. So if you are confused, or you suspect the a subsection of this report to be at odds with the behaviour of the compiler, you can easily find code which represents that subsection and find clarification.</p><p class="">In aid to that, links to files within appropriate subsystems of The Obelisk Compiler can be found in at the beginning of many sections.</p><p class="">This report contains many pieces of techincal information like code examples, and grammars.   These are rendered thus:</p><p class="example">I am a piece of technical information</p><h2 class="banner"><a name="syntax">2. Syntax</a></h2><p class="">This section deals with <a href="#lex"> lexical syntax</a> and <a href="#grammar"> Obelisk's grammar</a>.</p><h2 class="banner"><a name="semantics">3. Semantics</a></h2><p class="">Obelisks semantics are described in two parts:</p><p class="">* Checking an Obelisk program for <a href="#correct"> correctness</a>.</p><p class="">* <a href="#runtime"> Run-time semantics</a> of an Obelisk program.</p><p class="">The following formal definitions are used throughout this section:</p><p class="">The set of available <a href="#grammar"> Obelisks grammar elements</a> is defined as <span class="example"> O</span>.</p><p class="">An Obelisk program <span class="example"> P</span>, which is a valid production of Obelisk's grammar - a list of function definitions.  Hence:</p><p class="example">A <span class="math_symbol">&#8712;</span> P <span class="math_symbol">&#8658;</span> A = FunctionDefinition</p><h2 class="banner"><a name="correct">3.1. Correct Programs</a></h2><p class="">An Obelisk program must not be executed as specified in the <a href="#runtime"> run-time semantics</a> unless it is correct.</p><p class="">An Obelisk program is correct when it has these two properties:</p><p class="">* A program has correct <a href="#scope"> scoping</a>.</p><p class="">* A program exhibits <a href="#unification"> type unification</a>.</p><h2 class="banner"><a name="scope">3.1.1. Scope</a></h2><p class="stage">The <a href="Language/Obelisk/Scoper.hs"> scoper</a> ensures scoping rules are obeyed.</p><p class=""><span class="example"> next_scope</span> is a relationship between and sets of variables in scope and sets with new members.   It is defined for each grammar element which contains other elements (is a set).</p><p class="example"><span class="math_symbol">&#8704;</span> A. A <span class="math_symbol">&#8712;</span> Sets. <span class="math_symbol">&#8707;</span> S. <span class="math_symbol">&#8707;</span> Q. A <span class="math_symbol">&#8712;</span> O. A <span class="math_symbol">&#8866;</span> next_scope(A, S, Q) <span class="math_symbol">&#8658;</span> S <span class="math_symbol">&#8838;</span> Q.</p><p class="">Definitions for <span class="example"> new_scope</span> are given below.</p><p class=""><span class="example"> scope</span> is a function from a grammar element and a set of variables in scope to true or false. It is defined for each grammar element in O.</p><p class="example"><span class="math_symbol">&#8704;</span> A. <span class="math_symbol">&#8707;</span> S. A <span class="math_symbol">&#8712;</span> O. A <span class="math_symbol">&#8866;</span> scope(A, S)</p><p class="">Definitions for <span class="example"> scope</span> are given below.</p><p class="">Definitions follow:</p><p class="">If all the members of set are syntactic elements, with a <span class="example"> next_scope</span> rule then the set has correct scoping when all of its members have correct scoping in the context of some scoping set.</p><p class="example"><span class="math_symbol">&#8707;</span> D. <span class="math_symbol">&#8704;</span> A. A <span class="math_symbol">&#8712;</span> D. A <span class="math_symbol">&#8712;</span> O. <span class="math_symbol">&#8707;</span> S. <span class="math_symbol">&#8707;</span> Q. next_scope(O, S, Q). scope(A, Q) <span class="math_symbol">&#8660;</span> scope(D, S)</p><p class="">Hence a program P only has correct scoping when its elements have correct scoping:</p><p class="example"><span class="math_symbol">&#8704;</span> A. A <span class="math_symbol">&#8712;</span> P. next_scope(P, S, Q). scope(A, Q) <span class="math_symbol">&#8660;</span> scope(P, S)</p><p class="">A function definition <span class="example"> F</span> only has correct scoping when the set of its where clause constants <span class="example"> Wc</span> have correct scoping and the set of its where clause function definitions <span class="example"> Wf</span> have correct scopping and its block <span class="example"> Fb</span> has correct scoping.</p><p class="example"><span class="math_symbol">&#8707;</span>&nbsp;F.&nbsp;&nbsp;<br />Fb&nbsp;<span class="math_symbol">&#8712;</span>&nbsp;F.&nbsp;Fb&nbsp;=&nbsp;Block.&nbsp;<br />Wc&nbsp;<span class="math_symbol">&#8712;</span>&nbsp;F.&nbsp;Wc&nbsp;=&nbsp;Set.&nbsp;<span class="math_symbol">&#8704;</span>&nbsp;C.&nbsp;C&nbsp;<span class="math_symbol">&#8712;</span>&nbsp;Wc.&nbsp;C&nbsp;=&nbsp;ConstantDefinition.&nbsp;<br />Wf&nbsp;<span class="math_symbol">&#8712;</span>&nbsp;F.&nbsp;Wf&nbsp;=&nbsp;Set.&nbsp;<span class="math_symbol">&#8704;</span>&nbsp;G.&nbsp;G&nbsp;<span class="math_symbol">&#8712;</span>&nbsp;Wf.&nbsp;G&nbsp;=&nbsp;FunctionDefinition.&nbsp;&nbsp;<br /><span class="math_symbol">&#8707;</span>&nbsp;S.&nbsp;<span class="math_symbol">&#8707;</span>&nbsp;Bq.&nbsp;<span class="math_symbol">&#8707;</span>&nbsp;Wcq.&nbsp;<span class="math_symbol">&#8707;</span>&nbsp;Wfq.&nbsp;<br />new_scope(Fb,&nbsp;S,&nbsp;Bq).&nbsp;new_scope(Wc,&nbsp;S,&nbsp;Wcq).&nbsp;new_scope(Wf,&nbsp;S,&nbsp;Wfq).&nbsp;<br />scope(F,&nbsp;S)&nbsp;<span class="math_symbol">&#8660;</span>&nbsp;scope(Fb,&nbsp;Bq)&nbsp;<span class="math_symbol">&#8743;</span>&nbsp;scope(Wc,&nbsp;Wcq)&nbsp;<span class="math_symbol">&#8743;</span>&nbsp;scope(Wf,&nbsp;Wfq)</p><p class=""><span class="example"> next_scope</span> for the function's block <span class="example"> Fb</span> is defined to be the union of the function's own scope, the function's formal arguments, and all definitions in the where clause.</p><p class="example">next_scope</p><p class="">For an identifier I to be in scope, the string making up that identifier must be a member of the scoping set S.</p><p class="example"><span class="math_symbol">&#8704;</span> I. I <span class="math_symbol">&#8712;</span> S <span class="math_symbol">&#8658;</span> scope(I, S)</p></body></html>